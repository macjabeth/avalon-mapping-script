<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
    <TriggerPackage>
        <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>mapper</name>
            <script></script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList/>
            <regexCodePropertyList/>
            <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>login</name>
                <script>raiseEvent(&quot;mmp logged in&quot;, &quot;Avalon&quot;)
mmp.game = &quot;avalon&quot;</script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList>
                    <string>^\w+, you are most welcome to the Land of Avalon\.$</string>
                    <string>You are most welcome to the Land of Avalon.</string>
                </regexCodeList>
                <regexCodePropertyList>
                    <integer>1</integer>
                    <integer>3</integer>
                </regexCodePropertyList>
            </Trigger>
            <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>balances</name>
                <script>protocol.equilibrium = multimatches[2][2]:find('e', 1, true) and true or false
protocol.balance = not (multimatches[2][2]:find('y', 1, true) or multimatches[2][2]:find('z', 1, true)) and true or false</script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList>
                    <string>^\w+, you are most welcome to the Land of Avalon\.$</string>
                    <string>\d+m ([A-Za-z]*)</string>
                </regexCodeList>
                <regexCodePropertyList>
                    <integer>7</integer>
                    <integer>1</integer>
                </regexCodePropertyList>
            </Trigger>
            <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>interiors</name>
                <script>protocol.indoors = not (matches[2]:find('OPEN', 1, true)) and true or false

selectCaptureGroup(1)
setFgColor(255,255,255)
resetFormat()</script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ffffff</mFgColor>
                <mBgColor>#000000</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList>
                    <string>\[?InO=(\S+)\]?</string>
                </regexCodeList>
                <regexCodePropertyList>
                    <integer>1</integer>
                </regexCodePropertyList>
            </Trigger>
            <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>prompt</name>
                <script>raiseEvent('onPrompt')</script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList>
                    <string>\[?InO=(\S+)\]?</string>
                </regexCodeList>
                <regexCodePropertyList>
                    <integer>7</integer>
                </regexCodePropertyList>
            </Trigger>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="yes" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>protocol</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList>
                    <string>###</string>
                    <string>^###(.+)$</string>
                </regexCodeList>
                <regexCodePropertyList>
                    <integer>2</integer>
                    <integer>1</integer>
                </regexCodePropertyList>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>brief</name>
                    <script>protocol.room = matches[2]
protocol.area = matches[3]
protocol.environment = matches[4]</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>brief (.+) in (.+) - surveys as '(.*)'</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>1</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>exits</name>
                    <script>local to_exit = { no='n',so='s',ea='e',we='w',['do']='d',ou='o' }

protocol.exits = {}

for exit, stat in matches[2]:gmatch('(%D+)(%d)') do
  exit = to_exit[exit] or exit
  protocol.exits[mmp.anytolong(exit)] = tonumber(stat)
end

raiseEvent(&quot;onNewExits&quot;)</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>exits (\w+)</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>1</integer>
                    </regexCodePropertyList>
                </Trigger>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>gag</name>
                    <script>deleteLine()
tempLineTrigger(1,1,[[if line == '' then deleteLine() end]])</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>return true</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>4</integer>
                    </regexCodePropertyList>
                </Trigger>
            </TriggerGroup>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>speedwalking</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList/>
                <regexCodePropertyList/>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>have to swim</name>
                    <script>mmp.swim()</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You must swim to move yourself around in the water.</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>3</integer>
                    </regexCodePropertyList>
                </Trigger>
                <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>delays</name>
                    <script></script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList/>
                    <regexCodePropertyList/>
                </TriggerGroup>
                <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>failures</name>
                    <script></script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList/>
                    <regexCodePropertyList/>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>no exit</name>
                        <script>mmp.failpath()</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>You can't go that way!</string>
                            <string>The undergrowth is too thick to pass that way.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                            <integer>3</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>divine presence</name>
                        <script>mmp.failpath()</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>The divine presence of Zaphod forces you back whence you came.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>lockpicking</name>
                        <script>mmp.failpath()</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>You look up from your work and cease tinkering with the lock.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>tripped</name>
                        <script>mmp.failpath()</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>You are breathing deeply. You trip and fall in your hurry.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>salvo trap</name>
                        <script>tempLineTrigger(1, 1, [[
  if not (line == 'You set off an arrow trap but the shaft is deflected by your shield.') then
    mmp.failpath()
  end
]])</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>To your horror, you set off a salvo trap.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>levitating</name>
                        <script>mmp.failpath()</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>You cannot go down while levitating.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>spheres</name>
                        <script>mmp.failpath()</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>Some warding inherent in the surroundings denies your sorcerous-mist form.</string>
                            <string>Your ethereal spirit is prevented from moving</string>
                            <string>Some warding inherent in the surroundings denies your mist form.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                            <integer>2</integer>
                            <integer>3</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>woodlands</name>
                        <script>mmp.failpath()</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>Between the boughs of the ancient woodland is a thick tangle of holly and briar. You cannot pass within.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                        </regexCodePropertyList>
                    </Trigger>
                </TriggerGroup>
                <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>doors</name>
                    <script></script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList/>
                    <regexCodePropertyList/>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>failed to open door</name>
                        <script>mmp.failpath()</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>You ready yourself to forcibly unlock a wooden door.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>door locked</name>
                        <script>mmp.unlockDoor()</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>A wooden door is locked, and therefore cannot be opened.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>door in the way</name>
                        <script>mmp.openDoor()</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>There is a door that way, and it is shut.</string>
                            <string>There is a gate that way, and it is shut.</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                            <integer>3</integer>
                        </regexCodePropertyList>
                    </Trigger>
                </TriggerGroup>
            </TriggerGroup>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>visuals</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList/>
                <regexCodePropertyList/>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="yes" isColorTriggerBg="no">
                    <name>room name (eye)</name>
                    <script>if protocol and protocol.room == multimatches[1][2] then
  selectString('.', 1) replace(' -')
  cecho(' &lt;a_darkwhite&gt;(&lt;a_brown&gt;' .. protocol.environment .. '&lt;a_darkwhite&gt;)')
  cecho(' &lt;a_darkwhite&gt;(&lt;green&gt;' .. protocol.area .. '&lt;a_darkwhite&gt;)')
end

raiseEvent(&quot;onNewRoom&quot;)</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#ffff00</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>^([\w\s,'&quot;-]+)\.$</string>
                        <string>FG7BG0</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>1</integer>
                        <integer>6</integer>
                    </regexCodePropertyList>
                </Trigger>
            </TriggerGroup>
            <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                <name>tracking</name>
                <script></script>
                <triggerType>0</triggerType>
                <conditonLineDelta>0</conditonLineDelta>
                <mStayOpen>0</mStayOpen>
                <mCommand></mCommand>
                <packageName></packageName>
                <mFgColor>#ff0000</mFgColor>
                <mBgColor>#ffff00</mBgColor>
                <mSoundFile></mSoundFile>
                <colorTriggerFgColor>#000000</colorTriggerFgColor>
                <colorTriggerBgColor>#000000</colorTriggerBgColor>
                <regexCodeList/>
                <regexCodePropertyList/>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>truediscern</name>
                    <script>echo '  ('
mmp.echonums(multimatches[2][2], multimatches[3][2])
echo ')'</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>1</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You examine the clues, sniff the air and question your intuition; you see an echo of</string>
                        <string>^You examine the clues, sniff the air and question your intuition; you see an echo of (.+)\.$</string>
                        <string>^It is within (.+)\.$</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>2</integer>
                        <integer>1</integer>
                        <integer>1</integer>
                    </regexCodePropertyList>
                </Trigger>
                <TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>prescience</name>
                    <script></script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>100</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>You bow your head and enter the prescient trance.</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>3</integer>
                    </regexCodePropertyList>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>location</name>
                        <script>echo((' '):rep(80 - #line))
echo '(' mmp.echonums(matches[2], matches[3]) echo ')'</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>^I see .+ at &quot;(.+)&quot; in (.+)\.$</string>
                            <string>^I see .+ held by .+ at &quot;(.+)&quot;\.$</string>
                            <string>^I see .+ at &quot;(.+)&quot; inside the (.+ Guild)\.$</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>1</integer>
                            <integer>1</integer>
                            <integer>1</integer>
                        </regexCodePropertyList>
                    </Trigger>
                    <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                        <name>stop (prescience)</name>
                        <script>setTriggerStayOpen('prescience', 0)</script>
                        <triggerType>0</triggerType>
                        <conditonLineDelta>0</conditonLineDelta>
                        <mStayOpen>0</mStayOpen>
                        <mCommand></mCommand>
                        <packageName></packageName>
                        <mFgColor>#ff0000</mFgColor>
                        <mBgColor>#ffff00</mBgColor>
                        <mSoundFile></mSoundFile>
                        <colorTriggerFgColor>#000000</colorTriggerFgColor>
                        <colorTriggerBgColor>#000000</colorTriggerBgColor>
                        <regexCodeList>
                            <string>You can hold the prescient trance no longer and raise your head frustratedly, knowing more existed to discern...</string>
                            <string>^I see .+ at &quot;(.+)&quot; in (.+)\.$</string>
                        </regexCodeList>
                        <regexCodePropertyList>
                            <integer>3</integer>
                            <integer>7</integer>
                        </regexCodePropertyList>
                    </Trigger>
                </TriggerGroup>
                <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
                    <name>locate</name>
                    <script>mmp.locateAndEcho(multimatches[2][3], multimatches[2][2])</script>
                    <triggerType>0</triggerType>
                    <conditonLineDelta>0</conditonLineDelta>
                    <mStayOpen>0</mStayOpen>
                    <mCommand></mCommand>
                    <packageName></packageName>
                    <mFgColor>#ff0000</mFgColor>
                    <mBgColor>#ffff00</mBgColor>
                    <mSoundFile></mSoundFile>
                    <colorTriggerFgColor>#000000</colorTriggerFgColor>
                    <colorTriggerBgColor>#000000</colorTriggerBgColor>
                    <regexCodeList>
                        <string>An image of </string>
                        <string>^An image of (.+) appears; the location &quot;(.+)&quot; forming a fleeting backdrop to the vision\.$</string>
                    </regexCodeList>
                    <regexCodePropertyList>
                        <integer>2</integer>
                        <integer>1</integer>
                    </regexCodePropertyList>
                </Trigger>
            </TriggerGroup>
        </TriggerGroup>
    </TriggerPackage>
    <TimerPackage>
        <TimerGroup isActive="yes" isFolder="yes" isTempTimer="no" isOffsetTimer="no">
            <name>mapper</name>
            <script></script>
            <command></command>
            <packageName></packageName>
            <time>00:00:00.000</time>
            <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
                <name>check for updates periodically</name>
                <script>mmp.checkforupdate()</script>
                <command></command>
                <packageName></packageName>
                <time>01:00:00.000</time>
            </Timer>
        </TimerGroup>
    </TimerPackage>
    <AliasPackage>
        <AliasGroup isActive="yes" isFolder="yes">
            <name>mapper</name>
            <script></script>
            <command></command>
            <packageName></packageName>
            <regex></regex>
            <Alias isActive="yes" isFolder="no">
                <name>helpme</name>
                <script>local default = 'ccc'

local room = protocol.room
local area = protocol.area

send((matches[2] or default) .. ' need help at ' .. room .. ' in ' .. area)</script>
                <command></command>
                <packageName></packageName>
                <regex>^helpme(?: (.+))?$</regex>
            </Alias>
            <Alias isActive="yes" isFolder="no">
                <name>myloc</name>
                <script>local default = 'ccc'

local room = protocol.room
local area = protocol.area

send((matches[2] or default) .. ' I am at ' .. room .. ' in ' .. area)</script>
                <command></command>
                <packageName></packageName>
                <regex>^myloc(?: (.+))?$</regex>
            </Alias>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>mapping</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>option</name>
                    <script>if not matches[2] then
  mmp.settings:showAllOptions()
  return
end

local val = matches[4]
if val == 'true' or val == 'yes' or val == 'on' then
  val = true
end
if val == 'false' or val == 'no' or val == 'off' then
  val = false
end

mmp.settings:setOption(matches[3], val)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^mconfig( (\w+) (.*))?$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>add a room label</name>
                    <script>mmp.roomLabel(matches[2])</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^room label (.+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>view/delete area labels</name>
                    <script>mmp.areaLabels(matches[2])</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^area labels ?(.+)?$</regex>
                </Alias>
                <AliasGroup isActive="no" isFolder="yes">
                    <name>mm mapping</name>
                    <script></script>
                    <command></command>
                    <packageName></packageName>
                    <regex></regex>
                    <Alias isActive="yes" isFolder="no">
                        <name>manually set the room coordinates</name>
                        <script>-- want the current room, but we're lost
if matches[2] == '' and (not mmp.currentroom or not mmp.roomexists(mmp.currentroom)) then
  mmp.echo(&quot;Don't know where we are at the moment.&quot;)
  return
end

-- want another room, but it doesn't actually exist
if matches[2] ~= '' and not mmp.roomexists(matches[2]) then
  mmp.echo('v' .. matches[2] .. &quot; doesn't exist.&quot;)
  return
end

local m = matches[3]
local rid, rname = (matches[2] ~= '' and matches[2] or mmp.currentroom), (matches[2] ~= '' and getRoomName(matches[2]) or mmp.currentroomname)
local x, y, z

local function set() -- small func to set things
  setRoomCoordinates(rid, x, y, z)
  mmp.echo(string.format('%s (%d) is now at %dx, %dy, %dz.\n', rname, rid, x, y, z))
  centerview(rid)
end

-- let's be flexible and allow several ways if giving an arg
-- rc x y z
x, y, z = string.match(m, '(%-?%d+) (%-?%d+) (%-?%d+)')
if x then
  set()
  return
end

-- rc xx? yy? zz?
x, y, z = string.match(m, '(%-?%d+)x'), string.match(m, '(%-?%d+)y'), string.match(m, '(%-?%d+)z')
if x or y or z then
  -- merge w/ old coords if any are missing
  local ox, oy, oz = getRoomCoordinates(rid)
  x = x or ox
  y = y or oy
  z = z or oz
  set()
  return
end

-- rc left/west, right/east, ...
local ox, oy, oz = getRoomCoordinates(rid)
local has = table.contains
for w in string.gmatch(m, '%a+') do
  if has({'west', 'left', 'w', 'l'}, w) then
    x = (x or ox) - 1
    y = (y or oy)
    z = (z or oz)
  elseif has({'east', 'right', 'e', 'r'}, w) then
    x = (x or ox) + 1
    y = (y or oy)
    z = (z or oz)
  elseif has({'north', 'top', 'n', 't'}, w) then
    x = (x or ox)
    y = (y or oy) + 1
    z = (z or oz)
  elseif has({'south', 'bottom', 's', 'b'}, w) then
    x = (x or ox)
    y = (y or oy) - 1
    z = (z or oz)
  elseif has({'northwest', 'topleft', 'nw', 'tl'}, w) then
    x = (x or ox) - 1
    y = (y or oy) + 1
    z = (z or oz)
  elseif has({'northeast', 'topright', 'ne', 'tr'}, w) then
    x = (x or ox) + 1
    y = (y or oy) + 1
    z = (z or oz)
  elseif has({'southeast', 'bottomright', 'se', 'br'}, w) then
    x = (x or ox) + 1
    y = (y or oy) - 1
    z = (z or oz)
  elseif has({'southwest', 'bottomleft', 'sw', 'bl'}, w) then
    x = (x or ox) - 1
    y = (y or oy) - 1
    z = (z or oz)
  elseif has({'up', 'u'}, w) then
    x = (x or ox)
    y = (y or oy)
    z = (z or oz) + 1
  elseif has({'down', 'd'}, w) then
    x = (x or ox)
    y = (y or oy)
    z = (z or oz) - 1
  end
end
if x then
  set()
  return
end

mmp.echo([[Where do you want to move the room to?
  You can use direct coordinates or relative directions.]])</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^(?:rc|room coords) (?:v(\d+) )?(.+)$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>add a special exit</name>
                        <script>-- spe clear and spe list match on this
if matches[2] == 'clear' or matches[2] == 'list' then
  return
end

-- need the current room, but we're lost
if not mmp.currentroom or not mmp.roomexists(mmp.currentroom) then
  mmp.echo(&quot;Don't know where we are at the moment.&quot;)
  return
end

local otherroom = tonumber(matches[2]) or mmp.relativeroom(mmp.currentroom, matches[2])

-- need the another room, but it doesn't actually exist
if not otherroom or not mmp.roomexists(otherroom) then
  mmp.echo(matches[2] .. &quot; doesn't exist.&quot;)
  return
end

addSpecialExit(mmp.currentroom, tonumber(otherroom), matches[3])
addSpecialExit(mmp.currentroom, tonumber(otherroom), matches[3])
mmp.echo(string.format(&quot;Added special exit with command '%s' to %s (%d).&quot;, matches[3], getRoomName(otherroom), otherroom))
centerview(mmp.currentroom)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^(?:spe|exit special) (\w+) (.+)$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>add a special exit from one remote room to another</name>
                        <script>local room1, room2 = tonumber(matches[2]), tonumber(matches[3])

if not room1 or not mmp.roomexists(room1) then
  mmp.echo('Room #' .. matches[2] .. &quot; doesn't exist - create it first, or make sure you got the room ID right?&quot;)
  return
end

if not room2 or not mmp.roomexists(room2) then
  mmp.echo('Room #' .. matches[3] .. &quot; doesn't exist - create it first, or make sure you got the room ID right?&quot;)
  return
end

addSpecialExit(room1, room2, matches[4])
mmp.echo(string.format(&quot;Added special exit with command '%s' to from %s (%d) to %s (%d).&quot;, matches[4], getRoomName(room1), room1, getRoomName(room2), room2))</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^spev (\d+) (\d+) (.+)$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>list special exits</name>
                        <script>mmp.listSpecialExits(matches[2])</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^spe list(?: (.+))?$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>clear all special exits</name>
                        <script>-- want the current room, but we're lost
if not matches[2] and (not mmp.currentroom or not mmp.roomexists(mmp.currentroom)) then
  mmp.echo(&quot;Don't know where we are at the moment.&quot;)
  return
end

-- want another room, but it doesn't exist
if matches[2] and tonumber(matches[2]) and not mmp.roomexists(matches[2]) then
  mmp.echo('v' .. matches[2] .. &quot; doesn't exist.&quot;)
  return
end

-- or a relative one
if matches[2] and not tonumber(matches[2]) and not mmp.relativeroom(mmp.currentroom, matches[2]) then
  mmp.echo('There is no room ' .. matches[2] .. ' of us.')
  return
end

local rid = (not matches[2] and mmp.currentroom or (tonumber(matches[2]) or mmp.relativeroom(mmp.currentroom, matches[2])))

clearSpecialExits(rid)
mmp.echo(string.format('Cleared all special exits in %s (%d).\n', getRoomName(rid), rid))</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^(?:spe clear|exit special clear) ?(\w+)?$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>create a room</name>
                        <script>local m = matches[2]
local rid, rname
if mmp.roomexists(mmp.currentroom) then
  rid, rname = mmp.currentroom, mmp.currentroomname
end
local x, y, z

local function set(newid) -- small func to set things
  local rid = newid or createRoomID()
  addRoom(rid)
  setRoomCoordinates(rid, x, y, z)
  if mmp.roomexists(mmp.currentroom) then
    setRoomArea(rid, getRoomArea(mmp.currentroom))
  end
  if mmp.roomexists(mmp.currentroom) then
    setRoomEnv(rid, getRoomEnv(mmp.currentroom))
  end
  setExit(mmp.currentroom, rid, m)
  mmp.echo(string.format('Created new room (%d) at %dx, %dy, %dz.\n', rid, x, y, z))
  centerview(mmp.roomexists(mmp.currentroom) and mmp.currentroom or rid)
  if not mmp.roomexists(mmp.currentroom) then
    mmp.currentroom = rid
    mmp.currentroomname = ''
  end
end

-- let's be flexible and allow several ways if giving an arg
-- rc v# x y z
newid, x, y, z = string.match(m, 'v(%d+) (%-?%d+) (%-?%d+) (%-?%d+)')
if x then
  set(newid)
  return
end

-- rc x y z
x, y, z = string.match(m, '(%-?%d+) (%-?%d+) (%-?%d+)')
if x then
  set()
  return
end

if not rid then
  mmp.echo(&quot;Don't know where we are at the moment in order to use relative coordinates.&quot;)
  return
end

-- rc xx? yy? zz?
x, y, z = string.match(m, '(%-?%d+)x'), string.match(m, '(%-?%d+)y'), string.match(m, '(%-?%d+)z')
if x or y or z then
  -- merge w/ old coords if any are missing
  local ox, oy, oz = getRoomCoordinates(rid)
  x = x or ox
  y = y or oy
  z = z or oz
  set()
  return
end

-- rc left/west, right/east, ...
local ox, oy, oz = getRoomCoordinates(rid)
local has = table.contains
for w in string.gmatch(m, '%a+') do
  if has({'west', 'left', 'w', 'l'}, w) then
    x = (x or ox) - 1
    y = (y or oy)
    z = (z or oz)
  elseif has({'east', 'right', 'e', 'r'}, w) then
    x = (x or ox) + 1
    y = (y or oy)
    z = (z or oz)
  elseif has({'north', 'top', 'n', 't'}, w) then
    x = (x or ox)
    y = (y or oy) + 1
    z = (z or oz)
  elseif has({'south', 'bottom', 's', 'b'}, w) then
    x = (x or ox)
    y = (y or oy) - 1
    z = (z or oz)
  elseif has({'northwest', 'topleft', 'nw', 'tl'}, w) then
    x = (x or ox) - 1
    y = (y or oy) + 1
    z = (z or oz)
  elseif has({'northeast', 'topright', 'ne', 'tr'}, w) then
    x = (x or ox) + 1
    y = (y or oy) + 1
    z = (z or oz)
  elseif has({'southeast', 'bottomright', 'se', 'br'}, w) then
    x = (x or ox) + 1
    y = (y or oy) - 1
    z = (z or oz)
  elseif has({'southwest', 'bottomleft', 'sw', 'bl'}, w) then
    x = (x or ox) - 1
    y = (y or oy) - 1
    z = (z or oz)
  elseif has({'up', 'u'}, w) then
    x = (x or ox)
    y = (y or oy)
    z = (z or oz) + 1
  elseif has({'down', 'd'}, w) then
    x = (x or ox)
    y = (y or oy)
    z = (z or oz) - 1
  end
end
if x then
  set()
  return
end

mmp.echo([[Where do you want to move the room to?
  You can use direct coordinates or relative directions.]])</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^(?:rlc|room create) (.+)?$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>create a link between two rooms</name>
                        <script>-- need the current room, but we're lost
if not mmp.currentroom or not mmp.roomexists(mmp.currentroom) then
  mmp.echo(&quot;Don't know where we are at the moment.&quot;)
  return
end

-- make sure the dir is valid
local dir = mmp.anytolong(matches[3])
if not dir then
  mmp.echo(matches[3] .. &quot; isn't a valid normal exit.&quot;)
  return
end

-- if we don't give a room number, then we want to auto-locate an appropriate room nearby.
local otherroom
if matches[2] == '' then
  local w = matches[3]
  local ox, oy, oz, x, y, z = getRoomCoordinates(mmp.currentroom)
  local has = table.contains
  if has({'west', 'left', 'w', 'l'}, w) then
    x = (x or ox) - 1
    y = (y or oy)
    z = (z or oz)
  elseif has({'east', 'right', 'e', 'r'}, w) then
    x = (x or ox) + 1
    y = (y or oy)
    z = (z or oz)
  elseif has({'north', 'top', 'n', 't'}, w) then
    x = (x or ox)
    y = (y or oy) + 1
    z = (z or oz)
  elseif has({'south', 'bottom', 's', 'b'}, w) then
    x = (x or ox)
    y = (y or oy) - 1
    z = (z or oz)
  elseif has({'northwest', 'topleft', 'nw', 'tl'}, w) then
    x = (x or ox) - 1
    y = (y or oy) + 1
    z = (z or oz)
  elseif has({'northeast', 'topright', 'ne', 'tr'}, w) then
    x = (x or ox) + 1
    y = (y or oy) + 1
    z = (z or oz)
  elseif has({'southeast', 'bottomright', 'se', 'br'}, w) then
    x = (x or ox) + 1
    y = (y or oy) - 1
    z = (z or oz)
  elseif has({'southwest', 'bottomleft', 'sw', 'bl'}, w) then
    x = (x or ox) - 1
    y = (y or oy) - 1
    z = (z or oz)
  elseif has({'up', 'u'}, w) then
    x = (x or ox)
    y = (y or oy)
    z = (z or oz) + 1
  elseif has({'down', 'd'}, w) then
    x = (x or ox)
    y = (y or oy)
    z = (z or oz) - 1
  end

  local carea = getRoomArea(mmp.currentroom)
  if not carea then
    mmp.echo(&quot;Don't know what area are we in.&quot;)
    return
  end

  otherroom = select(2, next(getRoomsByPosition(carea, x, y, z)))

  if not otherroom then
    mmp.echo(&quot;There isn't a room to the &quot; .. w .. ' that I see - try with an exact room id.')
    return
  end
else
  if not mmp.roomexists(matches[2]) then -- check that an explicit other room ID is valid
    mmp.echo('A room with id ' .. matches[2] .. &quot; doesn't exist.&quot;)
    return
  else
    otherroom = tonumber(matches[2])
  end
end

if setExit(mmp.currentroom, otherroom, matches[3]) then
  if not matches[4] then
    setExit(otherroom, mmp.currentroom, mmp.ranytolong(matches[3]))
  end

  mmp.echo(string.format('Linked %s (%d) to %s (%d) via a %s%s exit.', (getRoomName(mmp.currentroom) ~= '' and getRoomName(mmp.currentroom) or &quot;''&quot;), mmp.currentroom, (getRoomName(otherroom) ~= '' and getRoomName(otherroom) or &quot;''&quot;), otherroom, (matches[4] and 'one-way ' or ''), matches[3]))
else
  mmp.echo(&quot;Couldn't create an exit.&quot;)
end
centerview(mmp.currentroom)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^(?:rlk|room link) ?(\d+)? (\w+)( one)?$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>merge rooms</name>
                        <script>mmp.merge_rooms()</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^merge rooms$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>delete a room</name>
                        <script>-- want the current room, but we're lost
if not matches[2] and (not mmp.currentroom or not mmp.roomexists(mmp.currentroom)) then
  mmp.echo(&quot;Don't know where we are at the moment.&quot;)
  return
end

-- want another room, but it doesn't exist
if matches[2] and tonumber(matches[2]) and not mmp.roomexists(matches[2]) then
  mmp.echo('v' .. matches[2] .. &quot; doesn't exist.&quot;)
  return
end

-- or a relative one
if matches[2] and not tonumber(matches[2]) and not mmp.relativeroom(mmp.currentroom, matches[2]) then
  mmp.echo('There is no room ' .. matches[2] .. ' of us.')
  return
end

local rid = (not matches[2] and mmp.currentroom or (tonumber(matches[2]) or mmp.relativeroom(mmp.currentroom, matches[2])))

local n = getRoomName(rid)
deleteRoom(rid)
mmp.echo(string.format('Deleted the %s (%d) room.\n', (n ~= '' and n or &quot;''&quot;), rid))
centerview(mmp.currentroom)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^(?:rld|room delete) ?(\w+)?$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>delete a link</name>
                        <script>-- need the current room, but we're lost
if not mmp.currentroom or not mmp.roomexists(mmp.currentroom) then
  mmp.echo(&quot;Don't know where we are at the moment.&quot;)
  return
end

-- make sure the dir is valid
local dir = mmp.anytolong(matches[2])
if not dir then
  mmp.echo(matches[2] .. &quot; isn't a valid normal exit.&quot;)
  return
end

-- gone already?
if not getRoomExits(mmp.currentroom)[dir] then
  mmp.echo(dir .. &quot; link doesn't exist already.&quot;)
end

-- locate the room on the other end, so we can unlink it from there as well if necessary
local otherroom
if getRoomExits(getRoomExits(mmp.currentroom)[dir])[mmp.ranytolong(dir)] then
  otherroom = getRoomExits(mmp.currentroom)[dir]
end

if setExit(mmp.currentroom, -1, dir) then
  if otherroom then
    if setExit(otherroom, -1, mmp.ranytolong(dir)) then
      mmp.echo(string.format('Deleted the %s exit from %s (%d).', dir, getRoomName(mmp.currentroom), mmp.currentroom))
    else
      mmp.echo(&quot;Couldn't delete the incoming exit.&quot;)
    end
  else
    mmp.echo(string.format('Deleted the one-way %s exit from %s (%d).', dir, getRoomName(mmp.currentroom), mmp.currentroom))
  end
else
  mmp.echo(&quot;Couldn't delete the outgoing exit.&quot;)
end
centerview(mmp.currentroom)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^(?:urlk|room unlink) (\w+)$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>move room to another area</name>
                        <script>mmp.roomArea(matches[2], matches[3])</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^room area (?:v(\d+) )?(.+)$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>set a room character</name>
                        <script>local room = matches[3] or mmp.currentroom
room = tonumber(room) or mmp.relativeroom(mmp.currentroom, room)
if not room or not mmp.roomexists(room) then
  mmp.echo(&quot;Sorry - which room do you want to put this character in? I don't know where you are at the moment, if you want to do the current room.&quot;)
  return
end

local char = matches[2]

if char == 'clear' then
  setRoomChar(room, ' ')
  mmp.echo('Cleared the character from ' .. room .. ' (' .. getRoomName(room) .. ')')
else
  setRoomChar(room, char)
  mmp.echo('Set the ' .. char:sub(1, 1) .. ' character on ' .. room .. ' (' .. getRoomName(room) .. ')')
end
centerview(mmp.currentroom)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^rcc ([^ ]+)(?: (\w+))?$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>set room weight</name>
                        <script>local weight = tonumber(matches[3]), room
if matches[2] == '' then
  room = mmp.currentroom
else
  room = tonumber(matches[2]) or mmp.relativeroom(mmp.currentroom, matches[2])
end

if not room or not mmp.roomexists(room) then
  mmp.echo(&quot;Sorry - which room do you want to set the weight on? I don't know where you are at the moment, if you want to do the current room.&quot;)
  return
end

if not weight then
  mmp.echo('What weight do you want to set on #' .. room .. '?')
end

local oldweight = getRoomWeight(room)
setRoomWeight(room, weight)

if weight &gt; oldweight then
  mmp.echo('Increased the room weight on #' .. room .. ' (' .. getRoomName(room) .. ') by ' .. (weight - oldweight) .. ' to ' .. weight .. ' - making it less desirable to travel through.')
elseif weight &lt; oldweight then
  mmp.echo('Decreased the room weight on #' .. room .. ' (' .. getRoomName(room) .. ') by ' .. (oldweight - weight) .. ' to ' .. weight .. ' - making it more desirable to travel through.')
else
  mmp.echo('The room weight on #' .. room .. ' (' .. getRoomName(room) .. ') is already ' .. weight .. '.')
end</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^rw(?: (\w+))? (\d+)$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>set exit weight</name>
                        <script>local room = (matches[2] ~= '' and tonumber(matches[2]) or mmp.currentroom)

local weight, exit = tonumber(matches[3]), matches[4]

if not roomExists(room) then
  mmp.echo('Room ' .. room .. &quot; doesn't exist. It has to before we can set weights on exits.&quot;)
  return
end

setExitWeight(room, exit, weight)

mmp.echo(string.format(&quot;Set the weight on the %d room going %s to %s. If it's a two-way exit, please set the reverse exit as well.&quot;, room, exit, weight))</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^rwe(?: (\d+))? (\d+) (.+)$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>add/delete doors</name>
                        <script>local room = (matches[2] ~= '' and tonumber(matches[2]) or mmp.currentroom)

local direction, status = matches[3], matches[4]

if not roomExists(room) then
  mmp.echo('Room ' .. room .. &quot; doesn't exist. It has to before we can make doors in it.&quot;)
  return
end

local validdirs = {'e', 's', 'w', 'n', 'ne', 'se', 'sw', 'nw', 'in', 'out', 'up', 'down'}

if not table.contains(validdirs, direction) then
  mmp.echo(&quot;Can't make a door in the '&quot; .. direction .. &quot;' direction - available choices are:\n  &quot; .. table.concat(validdirs, ', '))
  return
end

local statusnum

if status == '' or status == 'open' or status == 'o' then
  statusnum = 1
elseif status == 'closed' or status == 'c' then
  statusnum = 2
elseif status == 'locked' or status == 'l' then
  statusnum = 3
elseif status == 'clear' or status == 'gone' then
  statusnum = 0
end

if not statusnum then
  mmp.echo('Unrecognized option - a door can be open, closed, locked or gone.')
  return
end

setDoor(room, direction, statusnum)

if statusnum == 0 then
  mmp.echo('OK, door removed.')
else
  mmp.echo('OK, door added/adjusted.')
end</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^rd(?: (\d+))? (\w+)(?: (\w+))?$</regex>
                    </Alias>
                    <Alias isActive="no" isFolder="no">
                        <name>-- (area functions)</name>
                        <script></script>
                        <command></command>
                        <packageName></packageName>
                        <regex></regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>create an area</name>
                        <script>local t = getAreaTable()
local tr = {}
for k, v in pairs(t) do
  tr[v] = k
end
local newid = table.maxn(tr) + 1

setAreaName(newid, matches[2])
mmp.echo(string.format('Created new area %s (%d)', matches[2], newid))
centerview(mmp.currentroom)
raiseEvent('mmp areas changed')</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^area add (.+)$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>delete an area</name>
                        <script>mmp.deleteArea(matches[2])</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^area delete (.+)$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>cancel area deletion</name>
                        <script>if not mmp.deletingarea then
  mmp.echo(&quot;I wasn't deleting any areas already.&quot;)
  return
end

local areaname = mmp.deletingarea.areaname
mmp.deletingarea = nil

mmp.echo(&quot;Stopped deleting rooms in the '&quot; .. areaname .. &quot;'. The area is partially missing its rooms now, you'll want to restart the process to finish it.&quot;)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^cancel area deletion$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>rename an area</name>
                        <script>mmp.renameArea(matches[2])</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^area rename (.+)$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>list continents</name>
                        <script>local continents = mmp.getcontinents()

if not next(continents) then
  mmp.echo('No continents known.')
else
  for continent, areadata in pairs(continents) do
    mmp.echo(continent .. ' continent:')

    for _, areaid in ipairs(areadata) do
      cecho('  ' .. getRoomAreaName(areaid) .. '\n')
    end
  end
end</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^(?:acl|area continents)$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>add area to continent</name>
                        <script>-- ac continent [optional area]

local continent = matches[2]:title()
local area
if not matches[3] then
  area = getRoomArea(mmp.currentroom)
elseif tonumber(matches[3]) then
  area = tonumber(matches[3])
  if getRoomAreaName(area) == -1 then
    area = nil
  end
else
  local areas = getAreaTable()

  for karea, id in pairs(areas) do
    if karea:lower():find(matches[3]:lower(), 1, true) then
      area = id
      break
    end
  end
end

if not area then
  mmp.echo(matches[3] .. &quot; isn't a known area. Which one do you want to set?&quot;)
  return
end

local res, error = mmp.addcontinent(area, continent)
if res then
  mmp.echo('Recorded that ' .. getRoomAreaName(area) .. ' is on the ' .. continent .. ' continent.')
else
  mmp.echo(error)
end</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^ac ([\w']+)(?: (.+))?$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>remove area from continent</name>
                        <script>-- acr continent [optional area]

local continent = matches[2]:title()
local area
if not matches[3] then
  area = getRoomArea(mmp.currentroom)
elseif tonumber(matches[3]) then
  area = tonumber(matches[3])
  if getRoomAreaName(area) == -1 then
    area = nil
  end
else
  local areas = getAreaTable()

  for karea, id in pairs(areas) do
    if karea:lower():find(matches[3]:lower(), 1, true) then
      area = id
      break
    end
  end
end

if not area then
  mmp.echo(matches[3] .. &quot; isn't a known area. Which one do you want to set?&quot;)
  return
end

local res, error = mmp.removecontinent(area, continent)
if res then
  mmp.echo('Recorded that ' .. getRoomAreaName(area) .. ' is not on the ' .. continent .. ' continent.')
else
  mmp.echo(error)
end</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^acr ([\w']+)(?: (.+))?$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>add/remove a ferry room</name>
                        <script>local room = tonumber(matches[2])

-- load the ferry rooms if they haven't been already
if not mmp.ferry_rooms then
  local tmp = getRoomUserData(1, 'ferry rooms')

  mmp.ferry_rooms = {}
  if tmp ~= '' then
    for _, i in ipairs(yajl.to_value(tmp)) do
      mmp.ferry_rooms[i] = true
    end
  end
end

if matches[3] == 'add' then
  if mmp.ferry_rooms[room] then
    mmp.echo('Ferry room #' .. room .. ' is already recorded as such.')
    return
  else
    mmp.ferry_rooms[room] = true
    mmp.echo('Added #' .. room .. ' to be a ferry room.')
  end
else
  if not mmp.ferry_rooms[room] then
    mmp.echo('Room #' .. room .. &quot; isn't a ferry one already.&quot;)
    return
  else
    mmp.ferry_rooms[room] = nil
    mmp.echo('Removed #' .. room .. ' from being a ferry room.')
  end
end

local keys = {}
for k, _ in pairs(mmp.ferry_rooms) do
  keys[#keys + 1] = k
end

setRoomUserData(1, 'ferry rooms', yajl.to_string(keys))</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^fr (\d+) (add|remove)$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>show ferry rooms</name>
                        <script>if not mmp.ferry_rooms then
  local tmp = getRoomUserData(1, 'ferry rooms')

  mmp.ferry_rooms = {}
  if tmp ~= '' then
    for _, i in ipairs(yajl.to_value(tmp)) do
      mmp.ferry_rooms[i] = true
    end
  end
end

mmp.echo('Ferry rooms available:')
if not next(mmp.ferry_rooms) then
  mmp.echo('(none)')
  return
end

for k, _ in pairs(mmp.ferry_rooms) do
  mmp.echo(string.format('  (%d) - %s\n', k, getRoomName(k)))
end</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^fr show$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>weight ferry exits</name>
                        <script>local c = 0
local weight = 200
for area in pairs(mmp.areatabler) do
  local rooms = getAreaRooms(area) or {}
  for i = 0, #rooms do
    local exits = getSpecialExits(rooms[i] or 0)

    if exits and next(exits) then
      for exit, cmd in pairs(exits) do
        if type(cmd) == 'table' then
          cmd = next(cmd)
        end

        if (cmd:lower():find('buy passage to', 1, true)) then
          setExitWeight(rooms[i], cmd, weight)
          mmp.echo('Weighted ' .. cmd .. ' going to ' .. rooms[i] .. ' (' .. getRoomName(rooms[i]) .. ').')
          c = c + 1
        end
      end
    end
  end
end

mmp.echo(string.format(&quot;%s ferry exits weighted to %s (so we don't take them over too short distances).&quot;, c, weight))</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^weight ferry exits$</regex>
                    </Alias>
                    <Alias isActive="no" isFolder="no">
                        <name>-- (dangerous functions)</name>
                        <script></script>
                        <command></command>
                        <packageName></packageName>
                        <regex></regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>clear the map completely</name>
                        <script>if not mmp.map_delete_warning then
  mmp.echo(&quot;Are you really, really, really sure you want to delete all of the map to go to a blank state? Do the command again if you're certain.&quot;)
  mmp.map_delete_warning = true
  return
end

mmp.echo('Okay, deleting...')

tempTimer(.1, function()
  for name, id in pairs(getAreaTable()) do
    deleteArea(tonumber(id))
  end

  mmp.echo(&quot;Deleted everything. It's all gone.&quot;)
  mmp.map_delete_warning = nil
  centerview(1)
end)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^map delete all$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>delete shop stockroom exits</name>
                        <script>mmp.echo('Deleting all known stockroom exits (rooms with $ and a down exit)')
local c = 0

for area, areaname in pairs(mmp.areatabler) do
  local rooms = getAreaRooms(area) or {}
  for i = 0, #rooms do
    if rooms[i] then
      local char = getRoomChar(rooms[i])
      if char == '$' then
        local exits = getRoomExits(rooms[i]) -- retrieve after $, more efficient

        if exits.down then
          setExit(rooms[i], -1, 'down')
          mmp.echo(string.format('Deleted the stockroom exit at %s (#%d in %s)', getRoomName(rooms[i]), rooms[i], mmp.areatabler[getRoomArea(rooms[i])]))
          c = c + 1
        end
      end
    end
  end
end

mmp.echo(string.format('Deleted %s known stockroom exit%s.', c, (c ~= 1 and 's' or '')))
centerview(mmp.currentroom)</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^delete known stockrooms$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>clear continent data</name>
                        <script>if not mmp.wipingcontinents then
  mmp.wipingcontinents = true
  mmp.echo('Are you sure you want to wipe all continent data? If yes, do this again.')
  return
end
mmp.wipingcontinents = nil

local toserialize = yajl.to_string {}
setRoomUserData(1, 'areaContinents', toserialize)
mmp.echo('Wiped all continents data.')</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^clear continent data$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>delete suffixed periods</name>
                        <script>mmp.echo('Deleting removing all periods at the end of room names...')
local c = 0

for area, areaname in pairs(mmp.areatabler) do
  local rooms = getAreaRooms(area) or {}
  for i = 0, #rooms do
    local name = getRoomName(rooms[i] or 0)
    if string.ends(name, '.') then
      name = string.sub(name, 1, (#name - 1))
      setRoomName(rooms[i], name)
      mmp.echo(string.format(&quot;Patched up room #%s - '%s'&quot;, rooms[i], name))
      c = c + 1
    end
  end
end

mmp.echo(string.format('Fixed up %s room%s.', c, (c ~= 1 and 's' or '')))</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^delete suffixed periods$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>find single exits</name>
                        <script>local c = 0

local getAreaRooms, getRoomExits, contains, echoLink, getRoomEnv, envidsr = getAreaRooms, getRoomExits, table.contains, echoLink, getRoomEnv, mmp.envidsr

for area, id in pairs(getAreaTable()) do
  for _, roomid in pairs(getAreaRooms(id)) do
    local exits = getRoomExits(roomid)
    for dir, otherroom in pairs(exits) do
      local otherexits = getRoomExits(otherroom) or {}
      if not contains(otherexits, roomid) then
        echoLink(string.format('%s -&gt; %s is oneway (%s-&gt;%s type)\n', roomid, otherroom, (envidsr and envidsr[getRoomEnv(roomid)] or '?'), (envidsr and envidsr[getRoomEnv(otherroom)] or '?')), [[mmp.gotoRoom(]] .. roomid .. [[)]], 'Click to go to the start room ' .. roomid, true)
        c = c + 1
      end
    end
  end
end

mmp.echo(string.format('Found %s oneways.%s', c, (c &gt; 10 and ' Have fun. Click on lines to go to the rooms.' or '')))</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^find single exits$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>show char marks</name>
                        <script>local c = 0
local m = {}
local areas = getAreaTable()
local show_area = table.size(areas) &gt; 1 and true or false

for area, id in pairs(areas) do
  for _, roomid in pairs(getAreaRooms(id)) do
    local c = getRoomChar(roomid)
    if c ~= '' and c ~= ' ' then
      m[c] = m[c] or {}
      m[c][#m[c] + 1] = roomid
    end
  end
end

if not next(m) then
  mmp.echo('This map has no char marks on it. Do mc on and rcc &lt;mark&gt; in a room to add them!')
  return
end

for letter, rooms in pairs(m) do
  table.sort(rooms)
  mmp.echo('Rooms with the &lt;' .. mmp.settings.echocolour .. '&gt;' .. letter .. '&lt;reset&gt; character on them:')
  for i = 1, #rooms do
    if not show_area then
      cecho(string.format('  &lt;sea_green&gt;%-5s&lt;reset&gt; %s\n', rooms[i], getRoomName(rooms[i])))
    else
      cecho(string.format('  &lt;sea_green&gt;%-5s&lt;reset&gt; %-35s &lt;dim_grey&gt;(in&lt;reset&gt; %s&lt;dim_grey&gt;)\n', rooms[i], getRoomName(rooms[i]), mmp.areatabler[getRoomArea(rooms[i])]))
    end
  end
end</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^show char marks$</regex>
                    </Alias>
                    <Alias isActive="yes" isFolder="no">
                        <name>delete all special exits across a map</name>
                        <script>mmp.delSpecialExits(matches[2])</script>
                        <command></command>
                        <packageName></packageName>
                        <regex>^spe delete all(?: (.+))?$</regex>
                    </Alias>
                </AliasGroup>
                <Alias isActive="yes" isFolder="no">
                    <name>toggle mapping mode</name>
                    <script>if (matches[2] and matches[2] == 'on') or (not matches[2] and not mmp.editing) then
  mmp.editing = true
  enableAlias('mm mapping')

  mmp_regenerate_areas()
  mmp.highlight_unfinished_rooms()

  mmp.echo('Mapping mode enabled. Happy mapping!')
elseif (matches[2] and matches[2] == 'off') or (not matches[2] and mmp.editing) then
  mmp.editing = false
  disableAlias('mm mapping')
  mmp.echo('Mapping mode disabled.')
end</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^(?:mc|map create) ?(on|off)? ?(start)?$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>start mapping</name>
                    <script>mmp.start_mapping(matches[2] or protocol.area)
mmp.ignore_area_diff = matches[2] and true or false</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^start mapping ?(.+)?$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>clear moves</name>
                    <script>mmp.clear_moves()</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^clm$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>save a map</name>
                    <script>local function s(loc)
  if not saveMap(loc) then
    mmp.echo(&quot;Couldn't save the map :(&quot;)
  else
    if loc ~= '' then
      mmp.echo('Map saved.')
    else
      mmp.echo('Saved the default map.')
    end
  end
end

if not saveMap then
  mmp.echo(&quot;Your Mudlet can't save maps. Please upgrade it!&quot;)
else
  if matches[2] and matches[2] == 'custom' then
    s(invokeFileDialog(false, 'Please select the folder to save the map in and hit Open') .. '/Mudlet map from ' .. os.date(&quot;%A %d, %b '%y&quot;) .. '.dat')
  elseif matches[2] then
    s(getMudletHomeDir() .. '/map/' .. matches[2])
  else
    s('')
  end
end</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^map save(?: (.+))?$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>load a map</name>
                    <script>local function s(loc)
  if not loadMap(loc) then
    mmp.echo(&quot;Couldn't load the map :(&quot;)
  else
    if mmp.settings.waterwalk then
      mmp.enableWaterWalk()
    else
      mmp.disableWaterWalk()
    end

    if loc ~= '' then
      mmp.echo('Map loaded.')
    else
      mmp.echo('Loaded the default map.')
    end
    raiseEvent('mmapper updated map')
  end
end

if not loadMap then
  mmp.echo(&quot;Your Mudlet can't load maps. Please upgrade it!&quot;)
else
  if matches[2] and matches[2] == 'custom' then
    s(invokeFileDialog(true, 'Please select the map file and click Open to load it'))
  elseif matches[2] then
    s(getMudletHomeDir() .. '/map/' .. matches[2])
  else
    s('')
  end
end</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^map load(?: (.+))?$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>add room mark</name>
                    <script>local tmp = getRoomUserData(1, 'gotoMapping')
local maptable = {}

if tmp ~= '' then
  maptable = yajl.to_value(tmp)
end

local location, markname
if not matches[3] then
  markname = matches[2]
  location = mmp.currentroom
elseif tonumber(matches[2]) then
  location = matches[2]
  markname = matches[3]
else
  location = matches[3]
  markname = matches[2]
end

-- can't allow mark name to ne a number - yajl then generates a giant table of null's
if tonumber(markname) then
  mmp.echo(&quot;The mark name can't be a number.&quot;)
  return
end

maptable[markname] = location
local tmp2 = yajl.to_string(maptable)

if not mmp.roomexists(1) then
  addRoom(1)
end

setRoomUserData(1, 'gotoMapping', tmp2)
mmp.echo(string.format(&quot;Room mark for '%s' set to room %s.&quot;, markname, location))</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^room mark (\w+)(?: (\w+))?$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>remove room mark</name>
                    <script>local tmp = getRoomUserData(1, 'gotoMapping')
if tmp ~= '' then
  local maptable = yajl.to_value(tmp)
  if not maptable[matches[2]] then
    mmp.echo(&quot;Don't have such a mark in the db.&quot;)
    return
  end

  maptable[matches[2]] = nil
  local tmp2 = yajl.to_string(maptable)
  setRoomUserData(1, 'gotoMapping', tmp2)
  mmp.echo('Removed the ' .. matches[2] .. ' mark.')
else
  mmp.echo(&quot;We don't have any marks stored anyway.&quot;)
end</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^room unmark (\w+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>display room marks</name>
                    <script>local tmp = getRoomUserData(1, 'gotoMapping')
if tmp ~= '' then
  local maptable = yajl.to_value(tmp) or {}
  local sortedkeys = {}
  for k in pairs(maptable) do
    sortedkeys[#sortedkeys + 1] = k
  end
  table.sort(sortedkeys)

  mmp.echo('Known marks in this map:')
  if next(maptable) then
    for i = 1, #sortedkeys do
      echo(string.format('  %-21s  %s\n', tostring(sortedkeys[i]), tostring(maptable[sortedkeys[i]])))
    end
  else
    echo('  (none)\n')
  end
else
  mmp.echo('No marks are recorded in this map.')
end</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^room marks$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>toggle map sizes</name>
                    <script>local size = matches[2]

if size == 'biggest' then
  mapper = Geyser.Mapper:new({
    name = 'mapper',
    x = 0,
    y = 0,
    width = '100%',
    height = '97%'
  })
  mmp.echo('Map size set to pretty damn big.')
elseif size == 'small' then
  mapper = Geyser.Mapper:new({
    x = '70%',
    y = 0,
    width = '28%',
    height = '50%'
  })
  mmp.echo('Map size set to comfortable.')
elseif size == 'big' then
  local window_width, window_height = getMainWindowSize()
  local used_width = getMainConsoleWidth()

  local available_space = window_width - used_width

  if matches[3] then
    available_space = available_space - tonumber(matches[3])
  end

  mapper = Geyser.Mapper:new({
    x = available_space * -1,
    y = 0,
    width = available_space,
    height = '100%'
  })

  mmp.echo(&quot;Set the map size to big - it'll cover all of the space on the right that game text isn't using. You'll want to call this alias again if you resize the window to update.&quot;)
end</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^(small|big|biggest)map(?: (\d+))?$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>^make maps$</name>
                    <script>local c = 0
for _, id in pairs(getAreaTable()) do
  tempTimer(c * .5, [[exportAreaImage(]] .. id .. [[)]])
  c = c + 1
end
mmp.echo('Done!')</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^make maps$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>set debug mode</name>
                    <script>if matches[2] == 'on' then
  mmp.debug = true
else
  mmp.debug = false
end

mmp.echo('Debug &amp; performance telemetry ' .. (mmp.debug and 'enabled' or 'disabled') .. '.')</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^(?:mdg|mdebug) (on|off)$</regex>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>movement</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>go to id or area</name>
                    <script>local where = matches[2]:lower()
local gallop
if command:ends(&quot;gallop&quot;) then
  gallop = &quot;gallop&quot;
  where = where:sub(1, -8)
elseif command:ends(&quot;sprint&quot;) then
  gallop = &quot;sprint&quot;
  where = where:sub(1, -8)
end

if mmp.debug then
  mmp.gotoPerf = mmp.gotoPerf or createStopWatch()
  startStopWatch(mmp.gotoPerf)
end

-- goto room ID
if tonumber(where) then
	mmp.gotoRoom(where, gallop)
else
  	-- goto area
  local split = where:split(&quot; &quot;)
  if tonumber(split[#split]) then
    mmp.gotoArea(where:sub(1, -#(split[#split])-2), tonumber(split[#split]), gallop)
  else
    mmp.gotoArea(where, nil, gallop)
  end
end

if mmp.debug then
  mmp.echo(&quot;goto alias took &quot;..stopStopWatch(mmp.gotoPerf)..&quot;s to run.&quot;)
end</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^go (.+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>toggle pause</name>
                    <script>mmp.pause(matches[2])</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^mpp(?:\s?(on|off))?$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>stop walking</name>
                    <script>mmp.stop()</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^mstop$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>display area for lock/unlock</name>
                    <script>mmp.doLockArea(matches[2])</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^arealock(?: (.*))?$</regex>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>searching</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>view roomid or area</name>
                    <script>local where = matches[2]

if not where then
	centerview(mmp.currentroom)
elseif tonumber(where) then -- view a room ID
	centerview(where)
else -- view an area
	mmp.viewArea(where)
end</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^mmap ?(.+)?$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>room find</name>
                    <script>mmp.roomFind(matches[2])</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^(?:rf|room find) (.+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>room look</name>
                    <script>mmp.roomLook(matches[2])</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^(?:rl|room look)(?: (.+))?$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>room list</name>
                    <script>mmp.echoRoomList(matches[2] or mmp.areatabler[getRoomArea(mmp.currentroom)])</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^room list(?: (.+))?$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>area list</name>
                    <script>mmp.echoAreaList()</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^area list$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>get dirs</name>
                    <script>if not matches[2] and not matches[3] then
  mmp.echo(&quot;Where do you want to showpath to?&quot;)
elseif matches[2] and not matches[3] then
  mmp.echoPath(mmp.currentroom, matches[2])
else
  mmp.echoPath(matches[2], matches[3])
end</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^showpath(?: (\d+))?(?: (\d+))?$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>measure getpath()</name>
                    <script>mmp = mmp or {}

mmp.getPathPerf = mmp.getPathPerf or createStopWatch()
startStopWatch(mmp.getPathPerf)

local from, to = tonumber(matches[2]), tonumber(matches[3])

getPath(from, to)

mmp.echon = mmp.echon or echo
mmp.echon(&quot;a new getPath() from &quot;..from..&quot; to &quot;..to..&quot; took &quot;..stopStopWatch(mmp.getPathPerf)..&quot;s. There are &quot;..#speedWalkPath..&quot; rooms to visit in it.&quot;)
echo(&quot; &quot;)
echoLink(&quot;[unhighlight]&quot;, [[
  for room in pairs(mmp.getpathhighlights) do
    unHighlightRoom(room)
  end
]], &quot;Click me to remove highlighting from getpath&quot;)

mmp.getpathhighlights = mmp.getpathhighlights or {}

for room in pairs(mmp.getpathhighlights) do
  unHighlightRoom(room)
end

mmp.getpathhighlights = {}

local r,g,b = unpack(color_table.yellow)
local br,bg,bb = unpack(color_table.yellow)
-- add the first room to the speedWalkPath, as we'd like it highlighted as well
table.insert(speedWalkPath, 1, from)
for i = 1, #speedWalkPath do
  local room = speedWalkPath[i]
  highlightRoom(room, r,g,b,br,bg,bb, 1, 255, 255)
  mmp.getpathhighlights[room] = true
end

centerview(from)</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^getpath (?:from )?(\d+) (?:to )?(\d+)$</regex>
                </Alias>
                <Alias isActive="yes" isFolder="no">
                    <name>find me</name>
                    <script>mmp.find_me()</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^find me$</regex>
                </Alias>
            </AliasGroup>
            <AliasGroup isActive="yes" isFolder="yes">
                <name>tracking</name>
                <script></script>
                <command></command>
                <packageName></packageName>
                <regex></regex>
                <Alias isActive="yes" isFolder="no">
                    <name>check wholist</name>
                    <script>enableTrigger(&quot;Parse wholist&quot;)
send(&quot;who b&quot;)
tempTimer(10, [[disableTrigger'Parse wholist']])</script>
                    <command></command>
                    <packageName></packageName>
                    <regex>^who b$</regex>
                </Alias>
            </AliasGroup>
        </AliasGroup>
    </AliasPackage>
    <ActionPackage/>
    <ScriptPackage>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>mapper</name>
            <packageName></packageName>
            <script>mudlet = mudlet or {}; mudlet.mapper_script = true</script>
            <eventHandlerList/>
            <Script isActive="yes" isFolder="no">
                <name>create option table</name>
                <packageName></packageName>
                <script>function createOption(startingValue, onChangeFunc, allowedVarTypes, use, checkOption)
  if allowedVarTypes then -- make sure our starting Value follows type rules
    if not table.contains(allowedVarTypes, type(startingValue)) then
      echo('Starting type is not of allowed type!\n')
      display(allowedVarTypes)
      echo('type: ' .. type(startingValue) .. '\n')
      return
    end
  end

  local option = {
    value = startingValue,
    onChange = onChangeFunc,
    allowedVarTypes = allowedVarTypes,
    use = use or '',
    checkOption = checkOption or function()
      return true
    end
  }

  return option
end

function createOptionsTable(defaultTable)
  local index = {} -- index to store the default table at in our proxy table

  local proxyTable = {} -- This is the table that is returned to the user

  proxyTable.disp = echo

  proxyTable.dispDefaultWriteError = function()
    echo(&quot;Can't overwrite default options. Please use the SetOption function to change the value\n&quot;)
  end

  proxyTable.dispOption = function(opt, val)
    if not opt or not val then
      return
    end
    echo('Name: ' .. string.title(opt) .. string.rep(' ', 10 - string.len(opt)))
    echo('Val: ' .. tostring(val.value))
    echo(string.rep(' ', 10 - string.len(tostring(val.value))) .. '- ' .. val.use .. '\n')
  end

  function proxyTable:showAllOptions()
    proxyTable.disp('Available options: \n')
    for k, v in pairs(self[index]) do
      self.dispOption(k, v)
    end
    echo('\n')
    for k, v in pairs(self['_customOptions']) do
      self.dispOption(k, v)
    end
  end

  function proxyTable:getAllOptions()
    local t = {}
    for k, v in pairs(self[index]) do
      t[k] = v.value
    end

    return t
  end

  function proxyTable:setOption(option, value, silent)
    if self[option] == nil then
      proxyTable.disp('No such option!\n')
      return
    end

    -- otherwise, set the option
    if self['_customOptions'][option] then
      if not (table.contains(self['_customOptions'][option].allowedVarTypes, type(value)) and self['_customOptions'][option].checkOption(value)) then
        proxyTable.disp(&quot;You can't set '&quot; .. option .. &quot;' to that!\n&quot;)
        return
      end
      self['_customOptions'][option].value = value
      if self['_customOptions'][option].onChange then
        self['_customOptions'][option].onChange(option, value)
      end
    else
      if not (table.contains(self[index][option].allowedVarTypes, type(value)) and self[index][option].checkOption(value)) then
        proxyTable.disp(&quot;You can't set '&quot; .. option .. &quot;' to that!\n&quot;)
        return
      end
      rawset(self[index][option], 'value', value)
      local opt = rawget(self[index], option)
      if opt.onChange and not silent then
        opt.onChange(option, value)
      end
    end
    if mmp and mmp.clearpathcache then
      mmp.clearpathcache()
    end
  end

  proxyTable._customOptions = {}

  local mt = {
    __index = function(t, k)
      local custOp = rawget(t, '_customOptions')
      if custOp[k] then
        local opt = custOp[k]
        if opt then
          return opt.value
        else
          return nil
        end
      else
        local opt = t[index][k]
        if opt then
          return opt.value
        else
          return nil
        end
      end
    end,
    __newindex = function(t, k, v)
      if t[index][k] then
        proxyTable.dispDefaultWriteError()
      else
        t['_customOptions'][k] = v
      end
    end
  }

  proxyTable[index] = defaultTable

  setmetatable(proxyTable, mt)

  return proxyTable
end</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>load settings</name>
                <packageName></packageName>
                <script>-- mmp = mudlet mapper namespace
mmp = mmp or {
  paused = false,
  autowalking = false,
  currentroom = nil,
  currentroomname = nil,
  currentarea = nil,
  currentareaname = nil,
  firstRun = true,
  specials = {},
  ferry_rooms = {},
  move_queue = {}
}

speedWalkWatch = createStopWatch()

-- populated by Mudlet from getPath() and gotoRoom()
speedWalkPath = speedWalkPath or {}
speedWalkDir = speedWalkDir or {}
speedWalkCounter = 0

-- actually used by the mapper for walking
mmp.speedWalkPath = mmp.speedWalkPath or {}
mmp.speedWalkDir = mmp.speedWalkDir or {}

local newversion = '1.0.7'
if mmp.version and mmp.version ~= newversion then
  if not mmp.game then
    mmp.echo(&quot;Mapper script updated - Thanks! The mapper hasn't been initialised properly, though - so please reconnect, if you could.&quot;)
  else
    mmp.echo(&quot;Mapper script updated - thanks! You don't need to restart.&quot;)
  end
end
mmp.version = newversion

function mmp.startup()
  if not mmp.firstRun then return end

  local private_settings = {}
  --General settings
  private_settings['mode'] = createOption('normal', mmp.changeMode, {'string'}, 'Set the mode for mapping?') -- simple, normal, complex
  private_settings['echocolour'] = createOption('cyan', mmp.changeEchoColour, {'string'}, 'Set the color for room number echos?', function(newSetting) return color_table[newSetting] ~= nil end)
  private_settings['showcmds'] = createOption(true, mmp.changeBoolFunc, {'boolean'}, 'Show walking commands?')
  private_settings['slowwalk'] = createOption(false, mmp.setSlowWalk, {'boolean'}, 'Walk slowly instead of as quick as possible?')
  private_settings['waterwalk'] = createOption(true, mmp.setWaterWalk, {'boolean'}, &quot;Have waterwalk (don't avoid water)?&quot;)
  private_settings['stretchmap'] = createOption(false, mmp.setStretchMap, {'boolean'}, 'Stretch rooms when mapping to avoid clashes?')

  --locking things
  private_settings['lockspecials'] = createOption(false, mmp.lockSpecials, {'boolean'}, 'Lock all special exits?')

  --Sprint movement
  private_settings['sprint'] = createOption(false, mmp.changeBoolFunc, {'boolean'}, 'Use Sprint?')
  private_settings['gallop'] = createOption(false, mmp.changeBoolFunc, {'boolean'}, 'Use Gallop?')

  mmp.settings = createOptionsTable(private_settings)
  mmp.settings.disp = mmp.echo

  mmp.game = false

  mmp.settings.dispOption = function(opt, val)
    cecho('&lt;green&gt;' .. val.use .. '&lt;white&gt; (' .. opt .. ') ' .. string.rep(' ', 50 - val.use:len() - opt:len()) .. tostring(val.value) .. '\n')
  end

  mmp.settings.dispDefaultWriteError = function()
    mmp.echo('Please use the mconfig alias to set options!')
  end

  local tmp = getRoomUserData(1, 'ferry rooms')
  if tmp ~= '' then
    for _, i in ipairs(yajl.to_value(tmp)) do
      mmp.ferry_rooms[i] = true
    end
  end

  raiseEvent('mmp areas changed')
  mmp.firstRun = false
end</script>
                <eventHandlerList/>
            </Script>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>areas</name>
                <packageName></packageName>
                <script></script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>gotoArea</name>
                    <packageName></packageName>
                    <script>function mmp.gotoArea(where, number, dashtype, exact)
  if not where or type(where) ~= 'string' then
    mmp.echo('Where do you want to go to?')
    return
  end

  local where = where:lower()

  number = tonumber(number)
  local tmp = getRoomUserData(1, 'gotoMapping')
  if not tmp or tmp == '' then
    tmp = '[]'
  end

  local temp, maptable = yajl.to_value(tmp), {}
  for k, v in pairs(temp) do
    maptable[k:lower()] = v
  end

  local gotoID = maptable[where]
  if gotoID then
    mmp.gotoRoom(gotoID, dashtype)
    return
  end

  local possibleRooms, shortestPath, shortestBorder = {}, {}, 0

  mmp.computeShortestWatch = mmp.computeShortestWatch or createStopWatch()
  startStopWatch(mmp.computeShortestWatch)

  local areaid, msg, multiples = mmp.findAreaID(where, exact)
  if areaid then
    possibleRooms = mmp.getAreaBorders(areaid)
  elseif not areaid and #multiples &gt; 0 then
    if number and number &lt;= #multiples then
      mmp.gotoArea(multiples[number], nil, dashtype, true)
      return
    end
    mmp.echo('Which area would you like to go to?')
    fg('DimGrey')
    for key, areaname in ipairs(multiples) do
      echo '  '
      echoLink(key .. ') ', 'mmp.gotoArea(&quot;' .. areaname .. '&quot;, nil, ' .. (dashtype and '&quot;' .. dashtype .. '&quot;' or 'nil') .. ', true)', 'Click to go to ' .. areaname, true)
      setUnderline(true)
      echoLink(areaname, 'mmp.gotoArea(&quot;' .. areaname .. '&quot;, nil, ' .. (dashtype and '&quot;' .. dashtype .. '&quot;' or 'nil') .. ', true)', 'Click to go to ' .. areaname, true)
      setUnderline(false)
      echo '\n'
    end
    resetFormat()
    return
  else
    mmp.echo(string.format(&quot;Don't know of any area named '%s'.&quot;, where))
    return
  end

  local getStopWatchTime, tonumber, getPath = getStopWatchTime, tonumber, mmp.getPath

  -- allocate only 500ms to finding the shortest path, or more if we failed to find anything
  local checkedsofar, outoftime = 0
  for id, _ in pairs(possibleRooms) do
    if mmp.getPath(mmp.currentroom, tonumber(id)) then
      if shortestBorder == 0 or #shortestPath &gt; #speedWalkPath then
        shortestPath = speedWalkPath
        shortestBorder = tonumber(id)
      end
    end
    checkedsofar = checkedsofar + 1

    if (getStopWatchTime(mmp.computeShortestWatch) &gt;= .5) then
      outoftime = true
      break
    end
  end

  stopStopWatch(mmp.computeShortestWatch)

  if shortestBorder == 0 then
    if outoftime then
      mmp.echo(string.format('I checked %d of the %d possible exits &quot;%s&quot; has, but none of the ways there worked and it was taking too long :( try doing this again?', checkedsofar, table.size(possibleRooms), where))
    else
      mmp.echo('Checked ' .. table.size(possibleRooms) .. &quot; exits in that area, and none of them worked :( I Don't know how to get you there.&quot;)
    end
    mmp.speedWalkPath = {}
    mmp.speedWalkDir = {}
    speedWalkCounter = 0
    raiseEvent('mmapper failed path')
    return
  end

  mmp.gotoRoom(shortestBorder, dashtype)
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>echoAreaList</name>
                    <packageName></packageName>
                    <script>function mmp.echoAreaList()
  local list = getAreaTable()
  local ids, rlist = {}, {}
  local totalroomcount = 0
  for area, id in pairs(list) do
    if id ~= 0 then
      ids[#ids + 1] = id
      rlist[id] = area
    end
  end
  table.sort(ids)

  -- count the amount of rooms in an area, taking care to count the room in the 0th
  -- index as well if there is one
  -- saves the total room count on the side as well
  local function countrooms(areaid)
    local allrooms = getAreaRooms(areaid) or {}
    local areac = (#allrooms or 0) + (allrooms[0] and 1 or 0)
    totalroomcount = totalroomcount + areac
    return areac
  end

  cecho(string.format('&lt;DarkSlateGrey&gt;List of all areas we know of (click to view room list):\n'))
  local getAreaRooms, cecho, fg, echoLink, format, rep = getAreaRooms, cecho, fg, echoLink, string.format, string.rep
  for _, id in pairs(ids) do
    cecho(format('&lt;' .. mmp.settings.echocolour .. '&gt;%s%d ', rep(' ', (7 - #tostring(id))), id))
    -- +1 because getAreaRooms starts counting at 0
    fg('DarkSlateGrey')
    echoLink(rlist[id] .. (' '):rep(40 - #rlist[id]) .. '(' .. mmp.comma_value(countrooms(id)) .. ' rooms)', 'mmp.echoRoomList(&quot;' .. rlist[id] .. '&quot;, true)', 'View the room list for ' .. rlist[id], true)
    echo('\n')
  end
  cecho(string.format('&lt;DarkSlateGrey&gt;Total amount of rooms in this map: %s\n', mmp.comma_value(totalroomcount)))
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>deleteArea</name>
                    <packageName></packageName>
                    <script>function mmp.deleteArea(name, exact)
  local id, fname, ma = mmp.findAreaID(name, exact)

  if id then
    mmp.doareadelete(id)
  elseif next(ma) then
    mmp.echo('Which one of these specifically would you like to delete?')

    fg('DimGrey')
    for _, name in ipairs(ma) do
      echo '  '
      setUnderline(true)
      echoLink(name, [[mmp.deleteArea(&quot;]] .. name .. [[&quot;, true)]], 'Delete ' .. name, true)
      setUnderline(false)
      echo '\n'
    end
    resetFormat()
  else
    mmp.echo(&quot;Don't know of that area.&quot;)
  end

  raiseEvent('mmp areas changed')
end

-- the function actually doing area deletion
function mmp.doareadelete(areaid)
  mmp.deletingarea = {}

  local t = mmp.deletingarea

  local rooms = getAreaRooms(areaid)
  t.roomcount = table.size(rooms)
  t.roombatches = {}
  t.currentbatch = 1
  t.areaid = areaid
  t.areaname = getAreaTableSwap()[areaid]

  -- delete the area right away if there's nothing in it
  if t.roomcount == 0 then
    deleteArea(t.areaid)
    mmp.echo('All done! The area was already gone/empty.')
  end

  local rooms_per_batch = 100

  -- split up rooms into tables of tables, to be deleted in batches so
  -- that our print statements in between get a chance to be processed
  for batch = 1, t.roomcount, 100 do
    t.roombatches[#t.roombatches + 1] = {}
    local onebatch = t.roombatches[#t.roombatches]
    for inbatch = 1, 100 do
      onebatch[#onebatch + 1] = rooms[batch + inbatch]
    end
  end

  function mmp.deletenextbatch()
    local t = mmp.deletingarea
    if not t then
      return
    end

    local currentbatch = t.roombatches[t.currentbatchi]

    if currentbatch == nil then
      deleteArea(t.areaid)
      mmp.echo(&quot;All done! Deleted the '&quot; .. t.areaname .. &quot;' area.&quot;)
      mmp.deletingarea = nil
      centerview(mmp.currentroom)
      return
    end

    local deleteRoom = deleteRoom
    for i = 1, #currentbatch do
      deleteRoom(currentbatch[i])
    end

    mmp.echo(string.format('Deleted %d batch%s so far, %d left to go - %.2f%% done out of %d needed', t.currentbatchi, (t.currentbatchi == 1 and '' or 'es'), #t.roombatches - t.currentbatchi, (100 / #t.roombatches) * t.currentbatchi, #t.roombatches))

    t.currentbatchi = t.currentbatchi + 1
    tempTimer(0.010, mmp.deletenextbatch)
  end

  t.currentbatchi = 1
  mmp.echo('Prepped room batches, starting deletion...')
  tempTimer(0.010, mmp.deletenextbatch)
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>renameArea</name>
                    <packageName></packageName>
                    <script>function mmp.renameArea(name, exact)
  if not (mmp.currentroom or getRoomArea(mmp.currentroom)) then
    mmp.echo(&quot;Don't know what area are we in at the moment, to rename it.&quot;)
  else
    setAreaName(getRoomArea(mmp.currentroom), name)
    mmp.echo(string.format('Renamed %s to %s (%d).', mmp.areatabler[getRoomArea(mmp.currentroom)], name, getRoomArea(mmp.currentroom)))
    centerview(mmp.currentroom)
  end

  raiseEvent('mmp areas changed')
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>roomArea</name>
                    <packageName></packageName>
                    <script>function mmp.roomArea(otherroom, name, exact)
  local id, fname, ma
  if tonumber(name) then
    id = tonumber(name)
    fname = mmp.areatabler[id]
  else
    id, fname, ma = mmp.findAreaID(name, exact)
  end

  if otherroom ~= '' and not mmp.roomexists(otherroom) then
    mmp.echo('Room id ' .. otherroom .. &quot; doesn't seem to exist.&quot;)
    return
  elseif otherroom == '' and not mmp.roomexists(mmp.currentroom) then
    mmp.echo(&quot;Don't know where we are at the moment.&quot;)
    return
  end

  otherroom = otherroom ~= '' and otherroom or mmp.currentroom

  if id then
    setRoomArea(otherroom, id)
    mmp.echo(string.format('Moved %s to %s (%d).', (getRoomName(otherroom) ~= '' and getRoomName(otherroom) or &quot;''&quot;), fname, id))
    centerview(otherroom)
  elseif next(ma) then
    mmp.echo('Into which area exactly would you like to move the room?')

    fg('DimGrey')
    for _, name in ipairs(ma) do
      echo '  '
      setUnderline(true)
      echoLink(name, [[mmp.roomArea('', &quot;]] .. name .. [[&quot;, true)]], 'Move the room to ' .. name, true)
      setUnderline(false)
      echo '\n'
    end
    resetFormat()
  else
    mmp.echo(&quot;Don't know of that area.&quot;)
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>getAreaBorders</name>
                    <packageName></packageName>
                    <script>function mmp.getAreaBorders(areaid)
  if mmp.debug then
    mmp.getAreaBordersTimer = mmp.getAreaBordersTimer or createStopWatch()
    startStopWatch(mmp.getAreaBordersTimer)
  end

  local roomlist, endresult = getAreaRooms(areaid), {}
  -- sometimes getAreaRooms can give us no result :(
  if not roomlist then
    mmp.echo(&quot;Sorry, seems we can't go there - getAreaRooms(&quot; .. areaid .. &quot;) didn't give us any results (Mudlet problem - redownloading the map might help fix it)&quot;)
    return
  end

  -- make a key-value list of room IDs
  local reverselist = {}
  for i = 0, #roomlist do
    reverselist[roomlist[i]] = true
  end

  local getRoomName, contains, pairs = getRoomName, table.contains, pairs
  if getAllRoomEntrances then
    for i = 0, #roomlist do
      local id = roomlist[i]
      local entrancesFrom = getAllRoomEntrances(id)
      for remoteRoomIndex = 1, #entrancesFrom do
        if not reverselist[entrancesFrom[remoteRoomIndex]] then
          endresult[id] = getRoomName(id)
        end
      end
    end
  else
    local getRoomExits, getSpecialExitsSwap = getRoomExits, getSpecialExitsSwap

    -- obtain a room list for each of the room IDs we got
    --for _, id in pairs(roomlist) do
    for i = 0, #roomlist do
      local id = roomlist[i]
      local exits = getRoomExits(id)
      for _, to in pairs(exits) do
        if not reverselist[to] then
          endresult[id] = getRoomName(id)
        end
      end
      local specialexits = getSpecialExitsSwap(id)
      for _, to in pairs(specialexits) do
        if not reverselist[to] then
          endresult[id] = getRoomName(id)
        end
      end
    end
  end

  if mmp.debug then
    mmp.echo('mmp.getAreaBordersTimer() on areaid ' .. areaid .. ' took ' .. stopStopWatch(mmp.getAreaBordersTimer) .. 's to run. Returned ' .. table.size(endresult) .. ' results.')
  end

  return endresult
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>viewArea</name>
                    <packageName></packageName>
                    <script>function mmp.viewArea(where, exact)
  if not where or not type(where) == 'string' then
    mmp.echo('Which area would you like to view?')
    return
  end

  local areaid, msg, multiples = mmp.findAreaID(where, exact)
  if areaid then
    -- center on the first room ID, which typically is the start of an area
    local rooms = getAreaRooms(areaid) or {}
    if not rooms[1] then
      mmp.echo('The area has no rooms in it.')
    else
      centerview(rooms[1])
    end
  elseif not areaid and #multiples &gt; 0 then
    mmp.echo('Which area would you like to view exactly?')
    fg('DimGrey')
    for _, areaname in ipairs(multiples) do
      echo '  '
      setUnderline(true)
      echoLink(areaname, 'mmp.viewArea(&quot;' .. areaname .. '&quot;, true)', 'Click to view ' .. areaname, true)
      setUnderline(false)
      echo '\n'
    end
    resetFormat()
    return
  else
    mmp.echo(string.format(&quot;Don't know of any area named '%s'.&quot;, where))
    return
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>areaLabels</name>
                    <packageName></packageName>
                    <script>function mmp.areaLabels(where, exact)
  if not getMapLabels then
    mmp.echo(&quot;Your Mudlet doesn't support getMapLabels() yet - please update to 2.0-test3 or better.&quot;)
    return
  end

  if (not where or not type(where) == 'string') and not mmp.currentroom then
    mmp.echo('For which area would you like to view labels?')
    return
  end

  if not where then
    exact = true
    where = getRoomAreaName(getRoomArea(mmp.currentroom))
  end

  local areaid, msg, multiples = mmp.findAreaID(where, exact)
  if areaid then
    local t = getMapLabels(areaid)
    if type(t) ~= 'table' or not next(t) then
      mmp.echo(string.format(&quot;'%s' doesn't seem to have any labels.&quot;, getRoomAreaName(areaid)))
      return
    end

    mmp.echo(string.format(&quot;Area labels for '%s'&quot;, getRoomAreaName(areaid)))
    for labelid, labeltext in pairs(t) do
      fg('DimGrey')
      echo(string.format('  %d) %s (', labelid, labeltext))
      fg 'orange_red'
      setUnderline(true)
      echoLink('delete', string.format('deleteMapLabel(%d, %d); mmp.echo(&quot;Deleted label #' .. labelid .. '&quot;)', areaid, labelid), 'Delete label #' .. labelid .. ' from ' .. getRoomAreaName(areaid))
      setUnderline(false)
      echo ')\n'
    end
    resetFormat()
  elseif not areaid and #multiples &gt; 0 then
    mmp.echo('Which area would you like to view exactly?')
    fg('DimGrey')
    for _, areaname in ipairs(multiples) do
      echo '  '
      setUnderline(true)
      echoLink(areaname, 'mmp.areaLabels(&quot;' .. areaname .. '&quot;, true)', 'Click to view labels in ' .. areaname, true)
      setUnderline(false)
      echo '\n'
    end
    resetFormat()
    return
  else
    mmp.echo(string.format(&quot;Don't know of any area named '%s'.&quot;, where))
    return
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>findAreaID</name>
                    <packageName></packageName>
                    <script>function mmp.findAreaID(areaname, exact)
  local areaname = areaname:lower()
  local list = getAreaTable()

  -- iterate over the list of areas, matching them with substring match.
  -- if we get match a single area, then return it's ID, otherwise return
  -- 'false' and a message that there are than one are matches
  local returnid, fullareaname, multipleareas = nil, nil, {}
  for area, id in pairs(list) do
    if (not exact and area:lower():find(areaname, 1, true)) or (exact and areaname == area:lower()) then
      returnid = id
      fullareaname = area
      multipleareas[#multipleareas + 1] = area
    end
  end

  if #multipleareas == 1 then
    return returnid, fullareaname
  else
    return nil, nil, multipleareas
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>cleanAreaName</name>
                    <packageName></packageName>
                    <script>-- accepts areaname or ID
function mmp.cleanAreaName(area)
  local areaname = type(area) == 'number' and mmp.areatabler[area] or area
  if not areaname then
    return area
  end

  -- strip , the
  areaname = areaname:gsub(', the$', '')

  return areaname
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>getexactarea</name>
                    <packageName></packageName>
                    <script>-- if this room is in a unique area, report it. Otherwise gives nil
function mmp.getexactarea(roomname)
  local rooms = mmp.searchRoomExact(roomname)

  if not rooms or not next(rooms) then
    return nil
  end

  local areaid
  for roomid, roomname in pairs(rooms) do
    local caid = getRoomArea(roomid)
    if areaid and areaid ~= caid then
      return nil
    end
    areaid = caid
  end

  if areaid then
    return mmp.areatabler[areaid]
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>getAreaName</name>
                    <packageName></packageName>
                    <script>-- returns the area name of a room or ?
function mmp.getAreaName(roomid)
  return mmp.areatabler[getRoomArea(roomid)] or '?'
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>mmp_regenerate_areas</name>
                    <packageName></packageName>
                    <script>function mmp_regenerate_areas()
  -- cached data
  mmp.areatable = getAreaTable() -- this translates an area name to an ID
  mmp.areatabler = {} -- this translates an ID to an area name

  local t = getAreaTable()
  for k, v in pairs(t) do
    mmp.areatabler[tonumber(v)] = k
  end

  mmp.clearpathcache()
end</script>
                    <eventHandlerList>
                        <string>mmp areas changed</string>
                        <string>mmapper map reloaded</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>mmp_relock_areas</name>
                    <packageName></packageName>
                    <script>function mmp_relock_areas()
  local getAreaRooms, lockRoom, lockedareas = getAreaRooms, lockRoom, mmp.locked

  for areaid, areaname in pairs(getAreaTableSwap()) do
    if lockedareas[areaid] then
      local rooms = getAreaRooms(areaid) or {}
      for _, roomid in pairs(rooms) do
        lockRoom(roomid, true)
      end
    else
      local rooms = getAreaRooms(areaid) or {}
      for _, roomid in pairs(rooms) do
        lockRoom(roomid, false)
      end
    end
  end

  -- make sure area with ID 0 is locked - this was causing crashing issues
  local rooms = getAreaRooms(0) or {}
  for _, roomid in pairs(rooms) do
    lockRoom(roomid, true)
  end
end</script>
                    <eventHandlerList>
                        <string>mmapper map reloaded</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>filterRoomsByArea</name>
                    <packageName></packageName>
                    <script>function mmp.filterRoomsByArea(area, rooms)
  if not area then
    return rooms
  else
    local newrooms = {}
    for vnum, rname in pairs(rooms) do
      if mmp.getAreaName(vnum) == area then
        newrooms[vnum] = rname
      end
    end
    return newrooms
  end

  return false
end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>rooms</name>
                <packageName></packageName>
                <script></script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>gotoRoom</name>
                    <packageName></packageName>
                    <script>function mmp.gotoRoom(where, dashtype)
  if not where or not tonumber(where) then
    mmp.echo('Where do you want to go to?')
    return
  end

  if tonumber(where) == mmp.currentroom then
    mmp.echo(&quot;We're already at &quot; .. where .. '!')
    raiseEvent('mmapper arrived')
    return
  end

  -- allow mapper 'addons' to link their own exits in
  raiseEvent('mmp link externals')

  -- if getPath worked, then the dirs and room #'s tables were populated for us
  if not mmp.getPath(mmp.currentroom, tonumber(where)) then
    mmp.echo(&quot;Don't know how to get there (&quot; .. tostring(where) .. ') from here :(')
    mmp.speedWalkPath = {}
    mmp.speedWalkDir = {}
    speedWalkCounter = 0
    raiseEvent('mmapper failed path')
    -- allow mapper 'addons' to unlink their special exits
    raiseEvent('mmp clear externals')
    return
  end

  doSpeedWalk(dashtype)

  -- allow mapper 'addons' to unlink their special exits
  raiseEvent('mmp clear externals')
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>echonums</name>
                    <packageName></packageName>
                    <script>-- for a given room name, we'll echo all the vnums
function mmp.echonums(roomname, area)
  local t = mmp.searchRoomExact(roomname)

  if area then t = mmp.filterRoomsByArea(area, t) end

  if not next(t) then
    echo '?'
    return nil
  end

  -- transform the kv table into a table of tables for cleaner code.
  -- + perhaps Mudlet in future will give this us anyway, sorted by relevancy
  local dt = {}
  for roomid, room in pairs(t) do
    dt[#dt + 1] = {name = room, id = roomid}
  end

  -- we can have nothing if we asked for exact match
  if not dt[1] then
    echo '?---'
    return
  end

  -- display first three ids. Can't really nicely table.concat them.
  cechoLink('&lt;' .. mmp.settings.echocolour .. '&gt;' .. dt[1].id, 'mmp.gotoRoom(' .. dt[1].id .. ')', string.format('Go to %s (%s)', dt[1].id, dt[1].name), true)
  if not dt[2] then return end

  echo ', '
  cechoLink('&lt;' .. mmp.settings.echocolour .. '&gt;' .. dt[2].id, 'mmp.gotoRoom(' .. dt[2].id .. ')', string.format('Go to %s (%s)', dt[2].id, dt[2].name), true)
  if not dt[3] then return end

  echo ', '
  cechoLink('&lt;' .. mmp.settings.echocolour .. '&gt;' .. dt[3].id, 'mmp.gotoRoom(' .. dt[3].id .. ')', string.format('Go to %s (%s)', dt[3].id, dt[3].name), true)
  if not dt[4] then return end

  echo ', ...'
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>roomEcho</name>
                    <packageName></packageName>
                    <script>function mmp.roomEcho(query)
  local result = mmp.searchRoom(query)

  if not tonumber(select(2, next(result))) then
    for roomid, roomname in pairs(result) do
      roomid = tonumber(roomid)
      cecho('&lt;DarkSlateGrey&gt; (')
      cechoLink('&lt;' .. mmp.settings.echocolour .. '&gt;' .. roomid, 'mmp.gotoRoom(' .. roomid .. ')', string.format('Go to %s (%s)', roomid, tostring(roomname)), true)
      cecho('&lt;DarkSlateGrey&gt;)')
    end
  else
    for roomname, roomid in pairs(result) do
      roomid = tonumber(roomid)
      cecho('&lt;DarkSlateGrey&gt; (')
      cechoLink('&lt;' .. mmp.settings.echocolour .. '&gt;' .. roomid, 'mmp.gotoRoom(' .. roomid .. ')', string.format('Go to %s (%s)', roomid, tostring(roomname)), true)
      cecho('&lt;DarkSlateGrey&gt;)')
    end
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>locateAndEcho</name>
                    <packageName></packageName>
                    <script>function mmp.locateAndEcho(room, person, area)
  local t = mmp.searchRoomExact(room)

  if area then t = mmp.filterRoomsByArea(area, t) end

  echo '  ('
  mmp.echonums(room, area, true)
  echo ')'

  -- lowercase results
  for k, v in pairs(t) do
    if tonumber(k) then
      t[k] = v:lower()
    else
      t[k:lower()] = v
    end
  end

  if not (t[room:lower()] or table.contains(t, room:lower())) then
    return
  end

  echo '\n'
  if table.size(t) == 1 then
    local k, v = next(t)
    cecho('&lt;red&gt;From your knowledge, that room is in &lt;orange_red&gt;' .. mmp.cleanAreaName(mmp.areatabler[getRoomArea(type(k) == 'number' and k or v)] or '?') .. '&lt;red&gt;.')
  else
    local k, v = next(t)
    local areas = {}
    if type(k) == 'number' then
      for k, _ in pairs(t) do
        areas[mmp.areatabler[getRoomArea(k)] or '?'] = true
      end
    else
      for _, k in pairs(t) do
        areas[mmp.areatabler[getRoomArea(k)] or '?'] = true
      end
    end

    local flattened_areas = {}
    for k, _ in pairs(areas) do
      if k ~= '' then
        flattened_areas[#flattened_areas + 1] = mmp.cleanAreaName(k)
      end
    end

    cecho('&lt;red&gt;From your knowledge, that room might be in &lt;orange_red&gt;' .. table.concat(flattened_areas, ', or ') .. '&lt;red&gt;.')
  end

  if person then
    mmp.pdb[person] = room
    mmp.pdb_lastupdate[person] = true
    raiseEvent('mmapper updated pdb')
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>locateAndEchoSide</name>
                    <packageName></packageName>
                    <script>function mmp.locateAndEchoSide(room, person, area)
  local t = mmp.searchRoomExact(room)

  if area then t = mmp.filterRoomsByArea(area, t) end

  echo '  ('
  mmp.echonums(room, true)
  echo ')'

  -- lowercase results
  for k, v in pairs(t) do
    if tonumber(k) then
      t[k] = v:lower()
    else
      t[k:lower()] = v
    end
  end

  if not (t[room:lower()] or table.contains(t, room:lower())) then
    return
  end

  --echo&quot;\n&quot;
  if table.size(t) == 1 then
    local k, v = next(t)
    cecho('&lt;red&gt;  (' .. mmp.cleanAreaName(mmp.areatabler[getRoomArea(type(k) == 'number' and k or v)] or '?') .. ')')
  else
    local k, v = next(t)
    local areas = {}
    if type(k) == 'number' then
      for k, _ in pairs(t) do
        areas[mmp.areatabler[getRoomArea(k)] or '?'] = true
      end
    else
      for _, k in pairs(t) do
        areas[mmp.areatabler[getRoomArea(k)] or '?'] = true
      end
    end

    local flattened_areas = {}
    for k, _ in pairs(areas) do
      if k ~= '' then
        flattened_areas[#flattened_areas + 1] = mmp.cleanAreaName(k)
      end
    end

    cecho('&lt;red&gt; (' .. table.concat(flattened_areas, ', ') .. ')')
  end

  if person then
    mmp.pdb[person] = room
    mmp.pdb_lastupdate[person] = true
    raiseEvent('mmapper updated pdb')
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>locateAndEchoInternal</name>
                    <packageName></packageName>
                    <script>function mmp.locateAndEchoInternal(room, person, area)
  local t = mmp.searchRoomExact(room)

  if area then t = mmp.filterRoomsByArea(area, t) end

  -- lowercase results
  for k, v in pairs(t) do
    if tonumber(k) then
      t[k] = v:lower()
    else
      t[k:lower()] = v
    end
  end

  if not (t[room:lower()] or table.contains(t, room:lower())) then
    return
  end

  --echo&quot;\n&quot;
  if table.size(t) == 1 then
    local k, v = next(t)
    cecho('&lt;red&gt; in ' .. mmp.cleanAreaName(mmp.areatabler[getRoomArea(type(k) == 'number' and k or v)] or '?') .. '.')
  else
    local k, v = next(t)
    local areas = {}
    if type(k) == 'number' then
      for k, _ in pairs(t) do
        areas[mmp.areatabler[getRoomArea(k)] or '?'] = true
      end
    else
      for _, k in pairs(t) do
        areas[mmp.areatabler[getRoomArea(k)] or '?'] = true
      end
    end

    local flattened_areas = {}
    for k, _ in pairs(areas) do
      if k ~= '' then
        flattened_areas[#flattened_areas + 1] = mmp.cleanAreaName(k)
      end
    end

    cecho('&lt;red&gt; in ' .. table.concat(flattened_areas, ', ') .. '.')
  end

  echo '  ('
  mmp.echonums(room, true)
  echo ')'

  if person then
    mmp.pdb[person] = room
    mmp.pdb_lastupdate[person] = true
    raiseEvent('mmapper updated pdb')
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>roomWhoFind</name>
                    <packageName></packageName>
                    <script>function mmp.roomWhoFind(query)
  if query:ends('.') then
    query = query:sub(1, -2)
  end

  local result = mmp.searchRoomExact(query)

  if type(result) == 'string' or not next(result) then
    cecho('&lt;CadetBlue&gt;  You have no recollection of any room with that name.')
    return
  end

  if not tonumber(select(2, next(result))) then -- old style
    for roomid, roomname in pairs(result) do
      roomid = tonumber(roomid)
      cecho(string.format('  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (', tostring(roomname)))
      cechoLink('&lt;' .. mmp.settings.echocolour .. '&gt;' .. roomid, 'mmp.gotoRoom(' .. roomid .. ')', string.format('Go to %s (%s)', roomid, tostring(roomname)), true)
      cecho(string.format('&lt;DarkSlateGrey&gt;) &lt;white&gt;%s&lt;DarkSlateGrey&gt;.\n', tostring(mmp.areatabler[getRoomArea(roomid)])))
    end
  else -- new style
    for roomname, roomid in pairs(result) do
      roomid = tonumber(roomid)
      cecho(string.format('  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (', tostring(roomname)))
      cechoLink('&lt;' .. mmp.settings.echocolour .. '&gt;' .. roomid, 'mmp.gotoRoom(' .. roomid .. ')', string.format('Go to %s (%s)', roomid, tostring(roomname)), true)
      cecho(string.format('&lt;DarkSlateGrey&gt;) &lt;white&gt;%s&lt;DarkSlateGrey&gt;.\n', tostring(mmp.areatabler[getRoomArea(roomid)])))
    end
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>roomFind</name>
                    <packageName></packageName>
                    <script>function mmp.roomFind(query)
  if query:ends('.') then
    query = query:sub(1, -2)
  end
  local result = mmp.searchRoom(query)

  if type(result) == 'string' or not next(result) then
    cecho('&lt;grey&gt;You have no recollection of any room with that name.')
    return
  end

  cecho('&lt;DarkSlateGrey&gt;You know the following relevant rooms:\n')

  if not tonumber(select(2, next(result))) then -- old style
    for roomid, roomname in pairs(result) do
      roomid = tonumber(roomid)
      cecho(string.format('  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (', tostring(roomname)))
      cechoLink('&lt;' .. mmp.settings.echocolour .. '&gt;' .. roomid, 'mmp.gotoRoom(' .. roomid .. ')', string.format('Go to %s (%s)', roomid, tostring(roomname)), true)
      cecho(string.format('&lt;DarkSlateGrey&gt;) in &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt;.', mmp.cleanAreaName(tostring(mmp.areatabler[getRoomArea(roomid)]))))
      fg('DarkSlateGrey')
      echoLink(' &gt; Show path\n', [[mmp.echoPath(mmp.currentroom, ]] .. roomid .. [[)]], 'Display directions from here to ' .. roomname, true)
      resetFormat()
    end
  else -- new style
    for roomname, roomid in pairs(result) do
      roomid = tonumber(roomid)
      cecho(string.format('  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (', tostring(roomname)))
      cechoLink('&lt;' .. mmp.settings.echocolour .. '&gt;' .. roomid, 'mmp.gotoRoom(' .. roomid .. ')', string.format('Go to %s (%s)', roomid, tostring(roomname)), true)
      cecho(string.format('&lt;DarkSlateGrey&gt;) in &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt;.', mmp.cleanAreaName(tostring(mmp.areatabler[getRoomArea(roomid)]))))
      fg('DarkSlateGrey')
      echoLink(' &gt; Show path\n', [[mmp.echoPath(mmp.currentroom, ]] .. roomid .. [[)]], 'Display directions from here to ' .. roomname, true)
      resetFormat()
    end
  end

  cecho(string.format('  &lt;DarkSlateGrey&gt;%d rooms found.\n', table.size(result)))
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>echoRoomList</name>
                    <packageName></packageName>
                    <script>function mmp.echoRoomList(areaname, exact)
  local areaid, msg, multiples = mmp.findAreaID(areaname, exact)
  if areaid then
    local roomlist, endresult = getAreaRooms(areaid) or {}, {}

    -- obtain a room list for each of the room IDs we got
    local getRoomName = getRoomName
    for _, id in pairs(roomlist) do
      endresult[id] = getRoomName(id)
    end

    -- sort room IDs so we can display them in order
    table.sort(roomlist)

    -- now display something half-decent looking
    cecho(string.format('&lt;DarkSlateGrey&gt;List of all rooms in &lt;grey&gt;%s&lt;DarkSlateGrey&gt; (areaid &lt;grey&gt;%s&lt;DarkSlateGrey&gt; - &lt;grey&gt;%d&lt;DarkSlateGrey&gt; rooms):\n', msg, areaid, table.size(endresult)))
    local echoLink, sformat, fg, echo = echoLink, string.format, fg, cecho
    -- use pairs, as we can have gaps between room IDs
    for _, roomid in pairs(roomlist) do
      local roomname = endresult[roomid]
      fg('blue')
      cechoLink('&lt;' .. mmp.settings.echocolour .. '&gt;' .. sformat('%6s', roomid), 'mmp.gotoRoom(' .. roomid .. ')', string.format('Go to %s (%s)', roomid, tostring(roomname)), true)
      cecho(string.format('&lt;DarkSlateGrey&gt;: &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt;.\n', roomname))
    end
  elseif not id and #multiples &gt; 0 then
    mmp.echo('For which area would you want to list rooms for?')
    fg('DimGrey')
    for _, areaname in ipairs(multiples) do
      echo '  '
      setUnderline(true)
      echoLink(areaname, 'mmp.echoRoomList(&quot;' .. areaname .. '&quot;, true)', 'Click to view the room list for ' .. areaname, true)
      setUnderline(false)
      echo '\n'
    end
    resetFormat()
  else
    mmp.echo(string.format(&quot;Don't know of any area named '%s'.&quot;, areaname))
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>roomLabel</name>
                    <packageName></packageName>
                    <script>-- room label the room I'm in
-- room label 342 this is a label in room 342
-- room label green this is a green label where I'm at
-- room label green black this is a green to black label where I'm at
-- room label 34 green black this is a green to black label at room 34
-- how it works: split input string into tokens by space, then determine
-- what to do by checking first few tokens, and finally call the local
-- function with the proper arguments
function mmp.roomLabel(input)
  if not createMapLabel then
    mmp.echo(&quot;Your Mudlet doesn't support createMapLabel() yet - please update to 2.0-test3 or better.&quot;)
    return
  end

  local tk = input:split(' ')
  local room, fg, bg, message = mmp.currentroom, 'yellow', 'red', 'Some room label'

  -- input always have to be something, so tk[1] at least always exists
  if tonumber(tk[1]) then
    room = tonumber(table.remove(tk, 1)) -- remove the number, so we're left with the colors or msg
  end

  -- next: is this a foreground color?
  if tk[1] and color_table[tk[1]] then
    fg = table.remove(tk, 1)
  end

  -- next: is this a backround color?
  if tk[1] and color_table[tk[1]] then
    bg = table.remove(tk, 1)
  end

  -- the rest would be our message
  if tk[1] then
    message = table.concat(tk, ' ')
  end

  -- if we haven't provided a room ID and we don't know where we are yet, we can't make a label
  if not room then
    mmp.echo(&quot;We don't know where we are to make a label here.&quot;)
    return
  end

  local x, y = getRoomCoordinates(room)
  local f1, f2, f3 = unpack(color_table[fg])
  local b1, b2, b3 = unpack(color_table[bg])

  -- finally: do it :)

  local lid = createMapLabel(getRoomArea(room), message, x, y, f1, f2, f3, b1, b2, b3)
  mmp.echo(string.format(&quot;Created new label #%d '%s' in %s.&quot;, lid, message, getRoomAreaName(getRoomArea(room))))
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>getnums</name>
                    <packageName></packageName>
                    <script>function mmp.getnums(roomname, exact)
  if tonumber(roomname) then
    return {roomname}
  end

  local t = (not exact and mmp.searchRoom or mmp.searchRoomExact)(roomname)

  if not t or not next(t) then
    return nil
  end

  local result = {}

  if not tonumber(select(2, next(t))) then
    for roomid, _ in pairs(t) do
      if roomid ~= 0 then
        result[#result + 1] = tonumber(roomid)
      end
    end
  else
    for _, roomid in pairs(t) do
      if roomid ~= 0 then
        result[#result + 1] = tonumber(roomid)
      end
    end
  end

  return result
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>searchRoom</name>
                    <packageName></packageName>
                    <script>-- searchRoom with a cache!
local cache = {}
setmetatable(cache, {__mode = 'kv'}) -- weak keys/values = it'll periodically get cleaned up by gc

function mmp.searchRoom(what)
  local result = cache[what]
  if not result then
    result = searchRoom(what)
    local realResult = {}
    for key, value in pairs(type(result) == 'table' and result or {}) do
      -- both ways, because searchRoom can return either id-room name or the reverse
      if type(key) == 'string' then
        realResult[key] = value
      else
        realResult[key] = value
      end
    end
    cache[what] = realResult
    result = realResult
  end
  return result
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>searchRoomExact</name>
                    <packageName></packageName>
                    <script>local function endswith(s, suffix)
  return s:sub(#s - #suffix + 1) == suffix
end

function mmp.searchRoomExact(what)
  if type(what) ~= 'string' then
    return
  end

  local roomTable = mmp.searchRoom(what)
  local realResult = {}
  what = what:lower()
  for key, value in pairs(roomTable) do
    if type(key) == 'string' and (key:lower() == what or (endswith(key, '.') and key:sub(1, -2) == what)) then
      realResult[key] = value
    elseif type(value) == 'string' and (value:lower() == what or (endswith(value, '.') and value:sub(1, -2) == what)) then
      realResult[key] = value
    end
  end
  if (table.is_empty(realResult)) then
    return roomTable
  else
    return realResult
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>roomexists</name>
                    <packageName></packageName>
                    <script>function mmp.roomexists(num)
  if not num then
    return false
  end
  if roomExists then
    return roomExists(num)
  end

  local s, m = pcall(getRoomArea, tonumber(num))
  return (s and true or false)
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>cleanroomname</name>
                    <packageName></packageName>
                    <script>-- removes extra prefixes and suffixes that are not part of the actual room name
function mmp.cleanroomname(roomname)
  local starts, ends = string.starts, string.ends

  if ends(roomname, '.') then
    roomname = string.sub(roomname, 1, (#roomname - 1))
  end

  return roomname
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>roomLook</name>
                    <packageName></packageName>
                    <script>function mmp.roomLook(input)
  -- we can do a report with a number
  local function handle_number(num)
    -- compile all available data
    if not mmp.roomexists(num) then
      mmp.echo(num .. &quot; doesn't seem to exist.&quot;)
      return
    end
    local s, areanum = pcall(getRoomArea, num)
    if not s then
      mmp.echo(areanum)
      return
    end

    local exits = getRoomExits(num)
    local name = getRoomName(num)
    local islocked = roomLocked(num)
    local weight = (getRoomWeight(num) and getRoomWeight(num) or '?') -- getRoomWeight is buggy in one of the versions, is actually linked to setRoomWeight and thus returns nil
    local exitweights = (getExitWeights and getExitWeights(num) or {})
    local coords = {getRoomCoordinates(num)}
    local specexits = getSpecialExits(num)
    local env = getRoomEnv(num)
    local envname = (mmp.envidsr and mmp.envidsr[env]) or '?'

    -- generate a report
    mmp.echo(string.format('Room: %s #: %d area: %s (%d)', name, num, tostring(mmp.areatabler[areanum]), areanum))

    mmp.echo(string.format('Coordinates: x:%d, y:%d, z:%d, locked: %s, weight: %s', coords[1], coords[2], coords[3], (islocked and 'yep' or 'nope'), tostring(weight)))

    mmp.echo(string.format('Environment: %s (%d)%s', tostring(envname), env, (getRoomUserData(num, 'indoors') ~= '' and ', indoors' or '')))

    mmp.echo(string.format('Exits (%d):', table.size(exits)))
    for exit, leadsto in pairs(exits) do
      echo(string.format('  %s -&gt; %s (%d)%s%s\n', exit, getRoomName(leadsto), leadsto, ((getRoomArea(leadsto) or '?') == areanum and '' or ' (in ' .. (mmp.areatabler[getRoomArea(leadsto)] or '?') .. ')'), ((not exitweights[mmp.anytoshort(exit)] or exitweights[mmp.anytoshort(exit)] == 0) and '' or ' (weight: ' .. exitweights[mmp.anytoshort(exit)] .. ')')))
    end

    -- display special exits if we got any
    if next(specexits) then
      mmp.echo(string.format('Special exits (%d):', table.size(specexits)))

      for leadsto, command in pairs(specexits) do
        if type(command) == 'string' then
          echo(string.format('  %s -&gt; %s (%d)\n', command, getRoomName(leadsto), leadsto))
        else -- new format - exit name, command
          for cmd, locked in pairs(command) do
            if locked == '1' then
              cecho(string.format('&lt;DarkSlateGrey&gt;  %s -&gt; %s (%d) (locked)\n', cmd, getRoomName(leadsto), leadsto))
            else
              echo(string.format('  %s -&gt; %s (%d)\n', cmd, getRoomName(leadsto), leadsto))
            end
          end
        end
      end
    end

    -- actions we can do. This will be a short menu of sorts for actions
    mmp.echo('Stuff you can do:')
    echo '  '
    echo('Clear all labels ')
    setUnderline(true)
    echoLink('(in area)', 'mmp.clearLabels(' .. areanum .. ')', '', true)
    setUnderline(false)
    echo ' '
    setUnderline(true)
    echoLink('(whole map)', [[
    if not mmp.clearinglabels then
      mmp.echo(&quot;Are you sure you want to clear all of your labels on this map? If yes, click the link again.&quot;)
      mmp.clearinglabels = true
    else
      mmp.clearLabels(&quot;map&quot;)
      mmp.clearinglabels = nil
    end
    ]], '', true)
    setUnderline(false)
    echo '\n'
    echo '  '
    setUnderline(true)
    echoLink('Check for mapper &amp; map updates', 'mmp.echo(&quot;Checking...&quot;) mmp.checkforupdate()', '', true)
    setUnderline(false)
    echo '\n'
  end

  -- see if we can do anything with the name
  local function handle_name(name)
    local result = mmp.searchRoom(name)

    if type(result) == 'string' then
      cecho('&lt;grey&gt;You have no recollection of any room with that name.')
      return
    end

    -- if we got one result, then act on it
    if table.size(result) == 1 then
      if type(next(result)) == 'number' then
        handle_number(next(result))
      else
        handle_number(select(2, next(result)))
      end
      return
    end

    -- if not, then ask the user to clarify which one would they want
    mmp.echo('Which room specifically would you like to look up?')
    if not select(2, next(result)) or not tonumber(select(2, next(result))) then
      for roomid, roomname in pairs(result) do
        roomid = tonumber(roomid)
        cecho(string.format('  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (', tostring(roomname)))
        cechoLink('&lt;' .. mmp.settings.echocolour .. '&gt;' .. roomid, 'mmp.roomLook(' .. roomid .. ')', string.format('View room details for %s (%s)', roomid, tostring(roomname)), true)
        cecho(string.format('&lt;DarkSlateGrey&gt;) in the &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt;.\n', tostring(mmp.areatabler[getRoomArea(roomid)])))
      end
    else
      for roomname, roomid in pairs(result) do
        roomid = tonumber(roomid)
        cecho(string.format('  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (', tostring(roomname)))
        cechoLink('&lt;' .. mmp.settings.echocolour .. '&gt;' .. roomid, 'mmp.roomLook(' .. roomid .. ')', string.format('View room details for %s (%s)', roomid, tostring(roomname)), true)
        cecho(string.format('&lt;DarkSlateGrey&gt;) in the &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt;.\n', tostring(mmp.areatabler[getRoomArea(roomid)])))
      end
    end
  end

  if not input then
    if not mmp.roomexists(mmp.currentroom) then
      mmp.echo(mmp.currentroom .. &quot; doesn't seem to be mapped yet.&quot;)
      mmp.echo('Stuff you can do:')
      echo '  '
      echoLink('Check for all updates', 'mmp.echo(&quot;Checking...&quot;) mmp.checkforupdate()', '')
      echo '\n'
    else
      input = mmp.currentroom
    end
  end

  if tonumber(input) then
    handle_number(tonumber(input))
  else
    handle_name(input)
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>find_room</name>
                    <packageName></packageName>
                    <script>function mmp.find_room(name, area)
  -- looks for rooms with a particular name, and if given, in a specific area
  local rooms = searchRoom(name)
  if type(area) == 'string' then
    local areas = getAreaTable() or {}
    for k, v in pairs(areas) do
      if string.lower(k) == string.lower(area) then
        area = v
        break
      end
    end
    area = areas[area] or nil
  end
  for k, v in pairs(rooms) do
    if string.lower(v) ~= string.lower(name) then
      rooms[k] = nil
    elseif area and getRoomArea(k) ~= area then
      rooms[k] = nil
    end
  end
  return rooms
end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>continents</name>
                <packageName></packageName>
                <script></script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>getcontinents</name>
                    <packageName></packageName>
                    <script>function mmp.getcontinents()
  local tmp = getRoomUserData(1, 'areaContinents')
  if tmp == '' then
    return {}
  end

  return yajl.to_value(tmp)
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>removecontinent</name>
                    <packageName></packageName>
                    <script>function mmp.removecontinent(area, continent)
  local continents = mmp.getcontinents()

  if not next(continents) then
    return nil, 'no continents are known'
  end
  if not continents[continent] then
    return nil, 'no such continent is recorded'
  end

  local index = mmp.indexof_valueonly(continents[continent], area)
  if not index then
    return nil, 'this area is not on that continent'
  end
  table.remove(continents[continent], index)
  local tmp = yajl.to_string(continents)
  setRoomUserData(1, 'areaContinents', tmp)
  return true
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>addcontinent</name>
                    <packageName></packageName>
                    <script>function mmp.addcontinent(areaid, continent)
  local continents = mmp.getcontinents()

  if not continents[continent] then
    continents[continent] = {}
  end

  local index = mmp.indexof_valueonly(continents[continent], areaid)
  if index then
    return nil, 'this area is already on that continent'
  end
  continents[continent][#continents[continent] + 1] = areaid
  local tmp = yajl.to_string(continents)
  setRoomUserData(1, 'areaContinents', tmp)
  return true
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>oncontinent</name>
                    <packageName></packageName>
                    <script>-- checks if given area ID is on the given continent. Returns true only if certainly knows
function mmp.oncontinent(areaid, continent)
  local continents = mmp.getcontinents()
  if not continents[continent] then
    return nil, 'no such continent is recorded'
  end

  return mmp.indexof_valueonly(continents[continent], areaid)
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>getareacontinents</name>
                    <packageName></packageName>
                    <script>function mmp.getareacontinents(areaid)
  local areaContinents = {}
  for continentName, areas in pairs(mmp.getcontinents()) do
    if mmp.indexof_valueonly(areas, areaid) then
      areaContinents[#areaContinents + 1] = continentName
    end
  end
  return areaContinents
end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>tracking</name>
                <packageName></packageName>
                <script></script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>echoPath</name>
                    <packageName></packageName>
                    <script>function mmp.echoPath(from, to)
  assert(tonumber(from) and tonumber(to), 'mmp.getPath: both from and to have to be room IDs')
  if mmp.getPath(from, to) then
    mmp.echo('&lt;white&gt;Directions from &lt;yellow&gt;' .. string.upper(searchRoom(from)) .. ' &lt;white&gt;to &lt;yellow&gt;' .. string.upper(searchRoom(to)) .. '&lt;white&gt;:')
    mmp.echo(table.concat(speedWalkDir, ', '))
    return mmp.speedWalkDir
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>mmp.clearlastupdate</name>
                    <packageName></packageName>
                    <script>function mmp.clearlastupdate()
  -- reset mmp.pdb_lastupdate on the prompt
  enableTrigger&quot;mudlet mapper prompt trigger&quot;
end</script>
                    <eventHandlerList>
                        <string>mmapper updated pdb</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>person tracking</name>
                    <packageName></packageName>
                    <script>--[[
mmp will have 2 person tracking databases:
- mmp.pdb  =  used to store the last known location of a person
- mmp.pdb_lastupdate  =  used to store the output of the last locating command

Both databases work with the person's name as key and the location name as value.
]]

mmp.pdb = mmp.pdb or {}
mmp.pdb_lastupdate = mmp.pdb_lastupdate or {}

function mmp.is_here(who)
  return (mmp.pdb[who] and mmp.pdb[who] == mmp.currentroomname) and true or false
end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>speedwalking</name>
                <packageName></packageName>
                <script></script>
                <eventHandlerList/>
                <ScriptGroup isActive="yes" isFolder="yes">
                    <name>helpers</name>
                    <packageName></packageName>
                    <script></script>
                    <eventHandlerList/>
                    <Script isActive="yes" isFolder="no">
                        <name>canmove</name>
                        <packageName></packageName>
                        <script>function mmp.canmove(fromtimer)
  if protocol and protocol.equilibrium and protocol.balance then
    if fromtimer then
      mmp.move_logic()
    else
      return true
    end
  else
    tempTimer(0.2, [[mmp.canmove(true)]])
    return false
  end
end</script>
                        <eventHandlerList/>
                    </Script>
                    <Script isActive="yes" isFolder="no">
                        <name>pathcache</name>
                        <packageName></packageName>
                        <script>function mmp.clearpathcache()
  if mmp.debug then mmp.echo(&quot;path cache cleared&quot;) end
  getpathcache = {}
end
function mmp.showpathcache() return getpathcache end</script>
                        <eventHandlerList/>
                    </Script>
                </ScriptGroup>
                <Script isActive="yes" isFolder="no">
                    <name>speedwalking</name>
                    <packageName></packageName>
                    <script>local oldnum
function speedwalking(num)
  local num = tonumber(num)

  mmp.set_room(num)

  -- track if we're inside or outside, if possible
  if protocol then
    if mmp.inside and not protocol.indoors then
      mmp.inside = false
      raiseEvent('mmapper went outside')
    elseif not mmp.inside and protocol.indoors then
      mmp.inside = true
      raiseEvent('mmapper went inside')
    end
    if #table.n_union(mmp.getareacontinents(getRoomArea(mmp.previousroom or 0)), mmp.getareacontinents(getRoomArea(num))) ~= #mmp.getareacontinents(getRoomArea(num)) then
      raiseEvent('mmapper changed continent')
    end
    -- check for environment update, if we have environments mapped out
    if mmp.envids[protocol.environment] and mmp.envids[protocol.environment] ~= getRoomEnv(num) then
      setRoomEnv(num, mmp.envids[protocol.environment])
      mmp.echo(&quot;Updated environment to: &quot;..protocol.environment)
    end
    -- the event could cancel speedwalking - in this case quit
    if mmp.ignore_speedwalking then
      mmp.ignore_speedwalking = nil
      return
    end
  end

  if oldnum == num then
    return
  else
    oldnum = num
  end

  if not mmp.autowalking then
    return
  end

  if mmp.movetimer then
    killTimer(mmp.movetimer)
    mmp.movetimer = false
  end

  if num == mmp.speedWalkPath[#mmp.speedWalkPath] then
    local walktime = stopStopWatch(speedWalkWatch)
    mmp.echo(string.format(&quot;We've arrived! Took us %.1fs.\n&quot;, walktime))
    raiseEvent('mmapper arrived')
    mmp.speedWalkPath = {}
    mmp.speedWalkDir = {}
    speedWalkCounter = 0
    mmp.autowalking = false
  elseif mmp.speedWalkPath[speedWalkCounter] == num then
    speedWalkCounter = speedWalkCounter + 1
    mmp.move_logic()
  elseif #mmp.speedWalkPath &gt; 0 and not mmp.ferry_rooms[num] then -- ended up somewhere we didn't want to be, and this isn't a ferry room?
    speedWalkMoved = false
    -- re-calculate path then
    mmp.echo('Ended up off the path, recalculating a new path...')
    local destination = mmp.speedWalkPath[#mmp.speedWalkPath]
    if not mmp.getPath(num, destination) then
      mmp.echo(string.format(&quot;Don't know how to get to %d (%s) anymore :( Move into a room we know of to continue&quot;, destination, getRoomName(destination)))
    else
      mmp.gotoRoom(destination)
    end
  end
end</script>
                    <eventHandlerList/>
                    <Script isActive="yes" isFolder="no">
                        <name>move logic</name>
                        <packageName></packageName>
                        <script>function mmp.move_logic()
  local move = mmp.anytolong(mmp.speedWalkDir[speedWalkCounter]) or ''
  local stat = protocol.exits[move]

  if stat == 3 then
    mmp.unlockDoor()
  elseif stat == 2 then
    mmp.openDoor()
    protocol.exits[move] = 1
  else
    mmp.move()
  end
end</script>
                        <eventHandlerList/>
                    </Script>
                    <Script isActive="yes" isFolder="no">
                        <name>move</name>
                        <packageName></packageName>
                        <script>function mmp.setmovetimer(time)
  if mmp.movetimer then killTimer(mmp.movetimer) end
  if mmp.settings.slowwalk then return end

  mmp.movetimer = tempTimer(getNetworkLatency() + (time or 0.5), function()
    mmp.movetimer = false
    mmp.move()
  end)
end

-- moves to the next room we need to.
function mmp.move()
  if mmp.paused or not mmp.autowalking or mmp.movetimer or not mmp.canmove() then
    return
  end
  -- sometimes it's 0 - default to 1
  if speedWalkCounter == 0 then
    speedWalkCounter = 1
  end

  cmd = mmp.speedWalkDir[speedWalkCounter] or ''

  -- timeout before loadstring, so it can set its own if it would like to.
  mmp.setmovetimer()

  if string.starts(cmd, 'script:') then
    cmd = string.gsub(cmd, 'script:', '')
    loadstring(cmd)()
    if mmp.settings.showcmds then
      cecho(string.format('&lt;red&gt;(&lt;maroon&gt;%d - &lt;dark_slate_grey&gt;%s&lt;red&gt;)', #mmp.speedWalkDir - speedWalkCounter + 1, '&lt;script&gt;'))
    end
  else
    send(cmd, false)
    if mmp.settings.showcmds then
      cecho(string.format('&lt;red&gt;(&lt;maroon&gt;%d - &lt;dark_slate_grey&gt;%s&lt;red&gt;)', #mmp.speedWalkDir - speedWalkCounter + 1, cmd))
    end
    if mmp.unlocked_door then
      send('lock door ' .. mmp.ranytolong(cmd), false)
      mmp.unlocked_door = false
    end
  end
end</script>
                        <eventHandlerList/>
                    </Script>
                    <Script isActive="yes" isFolder="no">
                        <name>swim</name>
                        <packageName></packageName>
                        <script>function mmp.swim()
  if not mmp.autowalking then raiseEvent('onMoveFail') end

  -- not going anywhere? don't do anything
  if not mmp.speedWalkDir[speedWalkCounter] then
    return
  end

  send('swim ' .. mmp.speedWalkDir[speedWalkCounter]:gsub('sprint ', ''):gsub('gallop ', ''), false)
  if mmp.settings.showcmds then
    cecho(string.format('&lt;red&gt;(&lt;maroon&gt;%d - &lt;dark_slate_grey&gt;swim %s&lt;red&gt;)', #mmp.speedWalkDir - speedWalkCounter + 1, mmp.speedWalkDir[speedWalkCounter]:gsub('sprint ', ''):gsub('gallop ', '')))
  end

  mmp.setmovetimer(2.5)
end</script>
                        <eventHandlerList/>
                    </Script>
                    <Script isActive="yes" isFolder="no">
                        <name>doors</name>
                        <packageName></packageName>
                        <script>function mmp.openDoor()
  if not mmp.autowalking then raiseEvent('onMoveFail') end

  -- not going anywhere? don't do anything
  if not mmp.speedWalkDir[speedWalkCounter] then
    return
  end

  send('open door ' .. mmp.speedWalkDir[speedWalkCounter]:gsub('sprint ', ''):gsub('gallop ', ''), false)
  if mmp.settings.showcmds then
    cecho(string.format('&lt;red&gt;(&lt;maroon&gt;%d - &lt;dark_slate_grey&gt;open door %s&lt;red&gt;)', #mmp.speedWalkDir - speedWalkCounter + 1, mmp.speedWalkDir[speedWalkCounter]:gsub('sprint ', ''):gsub('gallop ', '')))
  end

  mmp.setmovetimer(getNetworkLatency())
end

function mmp.unlockDoor()
  if not mmp.autowalking then raiseEvent('onMoveFail') end

  -- not going anywhere? don't do anything
  if not mmp.speedWalkDir[speedWalkCounter] then
    return
  end

  send('unlock door ' .. mmp.speedWalkDir[speedWalkCounter]:gsub('sprint ', ''):gsub('gallop ', ''), false)
  if mmp.settings.showcmds then
    cecho(string.format('&lt;red&gt;(&lt;maroon&gt;%d - &lt;dark_slate_grey&gt;unlock door %s&lt;red&gt;)', #mmp.speedWalkDir - speedWalkCounter, mmp.speedWalkDir[speedWalkCounter]:gsub('sprint ', ''):gsub('gallop ', '')))
  end

  mmp.unlocked_door = true

  mmp.setmovetimer(getNetworkLatency() + 0.5)
end</script>
                        <eventHandlerList/>
                    </Script>
                    <Script isActive="yes" isFolder="no">
                        <name>delays</name>
                        <packageName></packageName>
                        <script>function mmp.customwalkdelay(delay)
  mmp.setmovetimer(getNetworkLatency() + delay)
end</script>
                        <eventHandlerList/>
                    </Script>
                    <Script isActive="yes" isFolder="no">
                        <name>stop</name>
                        <packageName></packageName>
                        <script>function mmp.stop()
  mmp.speedWalkPath = {}
  mmp.speedWalkDir = {}
  speedWalkCounter = 0
  stopStopWatch(speedWalkWatch)
  --if mmp.movetimer then killTimer( mmp.movetimer ) end
  mmp.autowalking = false

  -- clear all the temps we've got
  for trigger, ID in pairs(mmp.specials) do
    killTrigger(ID)
  end
  mmp.specials = {}

  mmp.echo('Stopped walking.')
  raiseEvent('mmapper stopped')
end</script>
                        <eventHandlerList/>
                    </Script>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>doSpeedWalk</name>
                    <packageName></packageName>
                    <script>function doSpeedWalk(dashtype)
  mmp.speedWalkDir = table.deepcopy(speedWalkDir)
  mmp.speedWalkPath = table.deepcopy(speedWalkPath)
  speedWalkDir, speedWalkPath = {}, {}

  resetStopWatch(speedWalkWatch)
  startStopWatch(speedWalkWatch)
  if mmp.settings['gallop'] or mmp.settings.sprint or dashtype then
    mmp.fixPath(mmp.currentroom, mmp.speedWalkPath[#mmp.speedWalkPath], (mmp.settings['gallop'] and 'gallop') or (mmp.settings.sprint and 'sprint') or dashtype)
  end

  mmp.fixSpecialExits(mmp.speedWalkDir)

  if #mmp.speedWalkPath == 0 then
    mmp.autowalking = false
    mmp.echo(&quot;Couldn't find a path to the destination :(&quot;)
    raiseEvent('mmapper failed path')
    return
  end

  -- this is a fix: convert nums to actual numbers
  for i = 1, #mmp.speedWalkPath do
    mmp.speedWalkPath[i] = tonumber(mmp.speedWalkPath[i])
  end

  mmp.autowalking = true
  raiseEvent('s')

  if not mmp.paused then
    mmp.echon('Starting speedwalk from ' .. mmp.currentroom .. ' to ')
    echoLink(mmp.speedWalkPath[#mmp.speedWalkPath], 'mmp.gotoRoom &quot;' .. mmp.speedWalkPath[#mmp.speedWalkPath] .. '&quot;', 'Go to ' .. mmp.speedWalkPath[#mmp.speedWalkPath])
    echo(': ')
    speedWalkCounter = 1
    if mmp.canmove() then
      mmp.move_logic()
    else
      echo(&quot;(when we get balance back / aren't hindered)&quot;)
    end
  else
    mmp.echo('Will go to ' .. mmp.speedWalkPath[#mmp.speedWalkPath] .. ' as soon as the mapper is unpaused.')
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>getPath</name>
                    <packageName></packageName>
                    <script>local getpathcache = {}

function mmp.getPath(from, to)
  assert(tonumber(from) and tonumber(to), 'mmp.getPath: both from and to have to be room IDs')

  local key = string.format('%s_%s', from, to)
  local resulttbl = getpathcache[key]

  -- not in cache?
  if not resulttbl then
    mmp.computeGetPath = mmp.computeGetPath or createStopWatch()
    startStopWatch(mmp.computeGetPath)
    local boolean = getPath(from, to)
    if mmp.debug then
      mmp.echo('a new getPath() from ' .. from .. ' to ' .. to .. ' took ' .. stopStopWatch(mmp.computeGetPath) .. 's.')
    end
    -- save it into the cache &amp; send away
    getpathcache[key] = {boolean, speedWalkDir, speedWalkPath}
    return boolean
  end

  -- or if it is, retrieve &amp; send away
  speedWalkDir = resulttbl[2]
  speedWalkPath = resulttbl[3]
  return resulttbl[1]
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>failpath</name>
                    <packageName></packageName>
                    <script>function mmp.failpath()
  if mmp.movetimer then
    local walktime = stopStopWatch(speedWalkWatch)
    mmp.echo(string.format(&quot;Can't continue further! Took us %.1fs to get here.\n&quot;, walktime))
  end

  mmp.autowalking = false
  mmp.speedWalkPath = {}
  mmp.speedWalkDir = {}
  speedWalkCounter = 0
  if mmp.movetimer then
    killTimer(mmp.movetimer)
    mmp.movetimer = nil
  end
  raiseEvent('mmapper failed path')
  raiseEvent('onMoveFail')
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>fixPath</name>
                    <packageName></packageName>
                    <script>function mmp.fixPath(rFrom, rTo, dashtype)
  local currentPath, currentIds = {}, {}
  local dRef = {['n'] = 'north', ['e'] = 'east', ['s'] = 'south', ['w'] = 'west'}
  if not getPath(rFrom, rTo) then
    return false
  end

  -- Logic: Look for a direction repeated at least two times.
  -- count the number of times it repeats, then look that many rooms ahead.
  -- if that room also contains the direction we're headed, just travel that many directions.
  -- otherwise, dash.

  local repCount = 1
  local index = 1
  local dashExaust = false
  while mmp.speedWalkDir[index] do
    dashExaust = false
    repCount = 1
    while mmp.speedWalkDir[index + repCount] == mmp.speedWalkDir[index] do
      repCount = repCount + 1
      if repCount == 21 then
        dashExaust = true
        break
      end
    end
    if repCount &gt; 1 then
      -- Found direction repitition. Calculate dash path.
      local exits = getRoomExits(mmp.speedWalkPath[index + (repCount - 1)])
      local pname = ''
      for word in mmp.speedWalkDir[index]:gmatch('%w') do
        pname = pname .. (dRef[word] or word)
      end
      if not exits[pname] or dashExaust then
        -- Final room in this direction does not continue, dash!
        table.insert(currentPath, string.format('%s %s', dashtype, mmp.speedWalkDir[index]))
        currentIds[#currentIds + 1] = mmp.speedWalkPath[index + repCount - 1]
      else
        for i = 1, repCount do
          table.insert(currentPath, mmp.speedWalkDir[index])
          currentIds[#currentIds + 1] = mmp.speedWalkPath[index + i - 1]
        end
      end
      index = index + repCount
    else
      -- No repetition, just add the direction.
      table.insert(currentPath, mmp.speedWalkDir[index])
      currentIds[#currentIds + 1] = mmp.speedWalkPath[index]
      index = index + 1
    end
  end

  mmp.speedWalkDir = currentPath
  mmp.speedWalkPath = currentIds
  return true
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>setSlowWalk</name>
                    <packageName></packageName>
                    <script>function mmp.setSlowWalk()
  if mmp.settings.slowwalk then
    mmp.echo(&quot;Will walk 'slowly' - that is, only try to move in a direction once per room, and move again once we've arrived. This will make us better walkers when it's very laggy, as we won't spam directions unnecessarily and miss certain turns - but it does mean that if we fail to move for some reason, we won't retry again either at all.&quot;)
  else
    mmp.echo('Will walk as quick as we can!')
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>setWaterWalk</name>
                    <packageName></packageName>
                    <script>function mmp.disableWaterWalk()
  local c = 0
  local getRoomEnv, setRoomWeight = getRoomEnv, setRoomWeight
  for roomid, roomname in pairs(getRooms()) do
    if mmp.waterenvs[getRoomEnv(roomid)] then
      setRoomWeight(roomid, 3)
      c = c + 1
    end
  end

  return c
end

function mmp.enableWaterWalk()
  local c = 0
  local getRoomEnv, setRoomWeight = getRoomEnv, setRoomWeight
  for roomid, roomname in pairs(getRooms()) do
    if mmp.waterenvs[getRoomEnv(roomid)] then
      setRoomWeight(roomid, 1)
      c = c + 1
    end
  end

  return c
end

function mmp.setWaterWalk()
  if mmp.settings.waterwalk then
    mmp.echo('Enabled waterwalk for ' .. mmp.enableWaterWalk() .. &quot; rooms - so we'll be treating land and water rooms the same now in terms of traverse speed over them.&quot;)
  else
    mmp.echo('Disabled waterwalk for ' .. mmp.disableWaterWalk() .. &quot; rooms - so we'll be preferring land rooms over water ones wherever it's quicker.&quot;)
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>setStretchMap</name>
                    <packageName></packageName>
                    <script>function mmp.setStretchMap()
  if mmp.settings.stretchmap then
    mmp.echo(&quot;Will stretch map - rooms will be automagically shuffled to avoid clashes.&quot;)
  else
    mmp.echo('Will let you do all the stretchy work, then!')
  end
end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>type definitions</name>
                <packageName></packageName>
                <script></script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>colour additions</name>
                    <packageName></packageName>
                    <script>color_table.a_darkred     = {128, 0, 0}
color_table.a_darkgreen   = {0, 179, 0}
color_table.a_brown       = {128, 128, 0}
color_table.a_darkblue    = {0, 0, 128}
color_table.a_darkmagenta = {128, 0, 128}
color_table.a_darkcyan    = {0, 128, 128}
color_table.a_grey        = {192, 192, 192}
color_table.a_darkgrey    = {128, 128, 128}
color_table.a_red         = {255, 0, 0}
color_table.a_green       = {0, 255, 0}
color_table.a_yellow      = {255, 255, 0}
color_table.a_blue        = {0, 85, 255}
color_table.a_magenta     = {255, 0, 255}
color_table.a_cyan        = {0, 255, 255}
color_table.a_white       = {255, 255, 255}
color_table.a_darkwhite   = {192, 192, 192}
color_table.a_darkyellow  = {179, 179, 0}
color_table.a_onelevel    = {45, 46, 46}
color_table.a_twolevel    = {103, 101, 98}
color_table.a_threelevel  = {67, 48, 32}
color_table.a_fourlevel   = {40, 186, 40}
color_table.a_fivelevel   = {57, 140, 57}
color_table.a_sixlevel    = {13, 121, 13}
color_table.blaze_orange  = {255, 102, 0}</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>avalon</name>
                    <packageName></packageName>
                    <script></script>
                    <eventHandlerList/>
                    <Script isActive="yes" isFolder="no">
                        <name>register_avalons_envdata</name>
                        <packageName></packageName>
                        <script>function register_avalons_envdata(_, game)
  if game ~= 'Avalon' then return end

  mmp.envids = {
    Barrack = 275,
    Beach = 267,
    City = 269,
    Field = 266,
    Forest = 258,
    Freshwater = 270,
    Grassland = 266,
    Marsh = 266,
    Mountains = 257,
    Nothing = 265,
    Plains = 259,
    Road = 262,
    Saltwater = 260,
    Sea = 268,
    Skies = 263,
    Snow = 271,
    Stockroom = 277,
    Store = 276,
    Swamp = 266,
    Tropical = 273,
    Underground = 272,
    Valley = 261,
    Void = 274,
  }

  mmp.waterenvs = {}
  local waterids = {'Freshwater', 'Saltwater', 'Sea'}
  for i = 1, #waterids do
    mmp.waterenvs[mmp.envids[waterids[i]]] = true
  end

  mmp.envidsr = {}
  for name, id in pairs(mmp.envids) do
    mmp.envidsr[id] = name
  end

  local custom_envs = {
    {273, 'orange'},
    {274, 'a_onelevel'},
    {275, 'purple'},
    {276, 'violet_red'},
    {277, 'orchid'}
  }

  for _, env in ipairs(custom_envs) do
    local r,g,b = unpack(color_table[env[2]])
    setCustomEnvColor(env[1], r,g,b, 255)
  end
end</script>
                        <eventHandlerList>
                            <string>mmp logged in</string>
                        </eventHandlerList>
                    </Script>
                    <Script isActive="yes" isFolder="no">
                        <name>mmapper_avalon_went_outside</name>
                        <packageName></packageName>
                        <script>-- track whenever we need to use the skies when we get outside!
function mmapper_avalon_went_outside()
  if not mmp.autowalking or mmp.game ~= 'avalon' or (mmp.currentroom == mmp.speedWalkPath[#mmp.speedWalkPath]) or protocol.indoors then
    return
  end

  -- repath, maybe that'll allow us to use wings now.
  raiseEvent('mmp link externals')
  local previousDirection = mmp.speedWalkDir[speedWalkCounter]
  mmp.getPath(mmp.currentroom, mmp.speedWalkPath[#mmp.speedWalkPath]) -- don't need to check return value since that fact shouldnt've changed

  -- if our path didn't change, re-instate it as it was (since the new path starts from this room that we checked at)
  if speedWalkDir[1] ~= previousDirection then
    speedWalkCounter = 0
    mmp.echo('We got outside - going to shortcut with skies.')
    mmp.gotoRoom(mmp.speedWalkPath[#mmp.speedWalkPath])
    mmp.ignore_speedwalking = true
  end
  raiseEvent('mmp clear externals')
end</script>
                        <eventHandlerList>
                            <string>mmapper went outside</string>
                            <string>mmapper changed continent</string>
                        </eventHandlerList>
                    </Script>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>habitats</name>
                    <packageName></packageName>
                    <script>habitats = {
  acaana = &quot;underground&quot;,
  adelsh = &quot;city&quot;,
  ajkara = &quot;swamp&quot;,
  akmar = &quot;mountains&quot;,
  aldaka = &quot;underground&quot;,
  alethe = &quot;forest&quot;,
  ambiarn = &quot;forest&quot;,
  arkasu = &quot;underground&quot;,
  athanzar = &quot;swamp&quot;,
  athillias = &quot;forest&quot;,
  atigax = &quot;freshwater&quot;,
  attanar = &quot;freshwater&quot;,
  blackroot = &quot;forest&quot;,
  bukandas = &quot;sea&quot;,
  bumba = &quot;plains&quot;,
  carnia = &quot;plains&quot;,
  courgia = &quot;mountains&quot;,
  dargwirith = &quot;forest&quot;,
  darsurion = &quot;forest&quot;,
  denallo = &quot;forest&quot;,
  dynallca = &quot;forest&quot;,
  echianta = &quot;swamp&quot;,
  erasmus = &quot;mountains&quot;,
  etarka = &quot;forest&quot;,
  exaar = &quot;forest&quot;,
  febfendu = &quot;freshwater&quot;,
  furglewort = &quot;forest&quot;,
  gilf = &quot;valley&quot;,
  grelixar = &quot;swamp&quot;,
  grimleaf = &quot;forest&quot;,
  gylvir = &quot;snow&quot;,
  harfy = &quot;forest&quot;,
  ikirax = &quot;freshwater&quot;,
  iorthir = &quot;valley&quot;,
  jegga = &quot;forest&quot;,
  jitsu = &quot;sea&quot;,
  karfar = &quot;forest&quot;,
  kaskamak = &quot;freshwater&quot;,
  kathkusa = &quot;valley&quot;,
  kelventari = &quot;forest&quot;,
  kly = &quot;forest&quot;,
  kural = &quot;freshwater&quot;,
  lestagii = &quot;valley&quot;,
  madabril = &quot;forest&quot;,
  malloran = &quot;freshwater&quot;,
  mandrake = &quot;forest&quot;,
  mar = &quot;snow&quot;,
  marsillas = &quot;swamp&quot;,
  megillos = &quot;forest&quot;,
  mouurark = &quot;valley&quot;,
  nann = &quot;mountains&quot;,
  ollso = &quot;plains&quot;,
  phoroz = &quot;snow&quot;,
  quarri = &quot;underground&quot;,
  quirrog = &quot;underground&quot;,
  rellick = &quot;forest&quot;,
  resik = &quot;swamp&quot;,
  sagar = &quot;swamp&quot;,
  sata = &quot;forest&quot;,
  semmory = &quot;forest&quot;,
  shirolos = &quot;forest&quot;,
  siriena = &quot;forest&quot;,
  surnamen = &quot;void&quot;,
  tyrlar = &quot;forest&quot;,
  ucklice = &quot;tropical&quot;,
  vaxvarna = &quot;mountains&quot;,
  wirren = &quot;beach&quot;,
  witan = &quot;freshwater&quot;,
  wurtfoil = &quot;forest&quot;,
  wyg = &quot;forest&quot;,
  yake = &quot;forest&quot;,
  yarl = &quot;underground&quot;,
  yavethalion = &quot;forest&quot;,
  yavin = &quot;valley&quot;,
  zaganzar = &quot;valley&quot;
}</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>mapping</name>
                <packageName></packageName>
                <script></script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>highlight unfinished rooms</name>
                    <packageName></packageName>
                    <script>-- functions internal to the mapper

function mmp.highlight_unfinished_rooms()
	if not mmp.areatable then return end
	for a,b in pairs (mmp.areatable) do
		local roomList = getAreaRooms(b) or {}
		for c,d in pairs (roomList) do
			if (getRoomName(d) == &quot;&quot;) then
				local fgr,fgg,fgb = unpack(color_table.red)
				local bgr,bgg,bgb = unpack(color_table.blue)
				highlightRoom(d, fgr,fgg,fgb,bgr,bgg,bgb, 1, 100, 100)
			end
		end
	end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>clearLabels</name>
                    <packageName></packageName>
                    <script>function mmp.clearLabels(areaid)
  local function clearlabels(areaid)
    local t = getMapLabels(areaid)
    if type(t) ~= 'table' then
      return
    end

    for labelid, _ in pairs(t) do
      deleteMapLabel(areaid, labelid)
    end
  end

  if areaid == 'map' then
    for areaid in pairs(mmp.areatabler) do
      clearlabels(areaid)
    end

    mmp.echo('Cleared labels in all of the map.')
    return
  end

  clearlabels(areaid)
  mmp.echo(string.format(&quot;Cleared all labels in '%s'.&quot;, mmp.areatabler[areaid]))
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>mmp_save_options</name>
                    <packageName></packageName>
                    <script>function mmp_save_options()
  local saveTable = {
    locked_areas = mmp.locked,
    options = mmp.settings:getAllOptions()
  }

  local _sep = string.char(getMudletHomeDir():byte()) == '/' and '/' or '\\'
  local saveFile = getMudletHomeDir() .. _sep .. 'mapper.options.lua'

  table.save(saveFile, saveTable)
end</script>
                    <eventHandlerList>
                        <string>sysExitEvent</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>mmp_load_options</name>
                    <packageName></packageName>
                    <script>function mmp_load_options()
  local loadTable = mmp_load_locks()

  if loadTable.options then
    for k, v in pairs(loadTable.options) do
      mmp.settings:setOption(k, v, true)
    end
  end
end

function mmp_load_locks()
  local loadTable = {}

  local _sep = string.char(getMudletHomeDir():byte()) == '/' and '/' or '\\'
  local loadFile = getMudletHomeDir() .. _sep .. 'mapper.options.lua'

  if io.exists(loadFile) then
    table.load(loadFile, loadTable)
  end

  if loadTable.locked_areas then
    mmp.locked = loadTable.locked_areas
  end

  local lockRoom, getAreaRooms = lockRoom, getAreaRooms
  for area in pairs(mmp.locked) do
    local rooms = getAreaRooms(area)
    for _, roomid in pairs(rooms or {}) do
      lockRoom(roomid, true)
    end
  end

  return loadTable
end</script>
                    <eventHandlerList>
                        <string>sysLoadEvent</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>changeMode</name>
                    <packageName></packageName>
                    <script>function mmp.changeMode()
  mmp.echo('Set mapping mode to: ' .. mmp.settings.mode)
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>mmp_mapping</name>
                    <packageName></packageName>
                    <script>mmp = mmp or {}

local room_detected, exits_detected, random_move

local exitmap = {
  n = 'north',
  ne = 'northeast',
  nw = 'northwest',
  e = 'east',
  w = 'west',
  s = 'south',
  se = 'southeast',
  sw = 'southwest',
  u = 'up',
  d = 'down',
  ['in'] = 'in',
  o = 'out'
}

local short = {}
for k, v in pairs(exitmap) do
  short[v] = k
end

local stubmap = {
  north = 1,
  northeast = 2,
  northwest = 3,
  east = 4,
  west = 5,
  south = 6,
  southeast = 7,
  southwest = 8,
  up = 9,
  down = 10,
  ['in'] = 11,
  out = 12,
  [1] = 'north',
  [2] = 'northeast',
  [3] = 'northwest',
  [4] = 'east',
  [5] = 'west',
  [6] = 'south',
  [7] = 'southeast',
  [8] = 'southwest',
  [9] = 'up',
  [10] = 'down',
  [11] = 'in',
  [12] = 'out'
}

local coordmap = {
  [1] = {0, 1, 0},
  [2] = {1, 1, 0},
  [3] = {-1, 1, 0},
  [4] = {1, 0, 0},
  [5] = {-1, 0, 0},
  [6] = {0, -1, 0},
  [7] = {1, -1, 0},
  [8] = {-1, -1, 0},
  [9] = {0, 0, 1},
  [10] = {0, 0, -1},
  [11] = {0, 0, 0},
  [12] = {0, 0, 0}
}

local reverse_dirs = {
  north = 'south',
  south = 'north',
  west = 'east',
  east = 'west',
  up = 'down',
  down = 'up',
  northwest = 'southeast',
  northeast = 'southwest',
  southwest = 'northeast',
  southeast = 'northwest',
  ['in'] = 'out',
  out = 'in'
}

function mmp.set_room(roomID)
  -- moves the mmp to the new room
  if mmp.currentroom ~= roomID then
    mmp.previousroom = mmp.currentroom
    mmp.currentroom = roomID
  end
  -- handle room changes
  if getRoomName(mmp.currentroom) ~= mmp.currentroomname then
    mmp.previousname = mmp.currentroomname
    mmp.previousexits = mmp.currentexits
    mmp.currentroomname = getRoomName(mmp.currentroom)
    mmp.currentexits = getRoomExits(mmp.currentroom)
    -- check handling of custom exits here
    for i = 13, #stubmap do
      mmp.currentexits[stubmap[i]] = tonumber(getRoomUserData(mmp.currentroom, 'exit ' .. stubmap[i]))
    end
  end
  -- handle area changes
  if getRoomArea(mmp.currentroom) ~= mmp.currentarea then
    mmp.ignore_area_diff = false
  end
  mmp.currentarea = getRoomArea(mmp.currentroom)
  mmp.currentareaname = getRoomAreaName(mmp.currentarea)
  centerview(mmp.currentroom)
end

local function add_door(roomID, dir, status)
  -- create or remove a door in the designated direction
  -- consider options for adding pickable and passable information
  dir = exitmap[dir] or dir
  if not table.contains(exitmap, dir) then
    error('Add Door: invalid direction.', 2)
  end
  if type(status) == 'string' then
    status = assert(table.index_of({'none', 'open', 'closed', 'locked'}, status), 'Add Door: Invald status, must be none, open, closed, or locked') - 1
  end
  local exits = getRoomExits(roomID)
  -- check handling of custom exits here
  if not exits[dir] and stubmap[dir] &lt;= 12 then
    setExitStub(roomID, stubmap[dir], true)
  elseif stubmap[dir] &gt; 12 and not tonumber(getRoomUserData(roomID, 'exit ' .. dir)) then
    setRoomUserData(roomID, 'stub' .. dir, stubmap[dir])
  end
  setDoor(roomID, table.contains({'up', 'down', 'in', 'out'}, dir) and dir or short[dir], status)
end

local function check_doors(roomID, exits)
  -- looks to see if there are doors in designated directions
  -- used for room comparison, can also be used for pathing purposes
  if type(exits) == 'string' then
    exits = {exits}
  end
  local statuses = {}
  local doors = getDoors(roomID)
  -- check handling of custom exits here
  for i = 9, #stubmap do
    doors[short[stubmap[i]]] = tonumber(getRoomUserData(roomID, 'door ' .. stubmap[i]))
  end
  local dir
  for k, v in pairs(exits) do
    dir = short[k] or short[v]
    if not doors[dir] or doors[dir] == 0 then
      return false
    else
      statuses[dir] = doors[dir]
    end
  end
  return statuses
end

local function find_room(name, area)
  -- looks for rooms with a particular name, and if given, in a specific area
  local rooms = searchRoom(name)
  if type(area) == 'string' then
    local areas = getAreaTable() or {}
    for k, v in pairs(areas) do
      if string.lower(k) == string.lower(area) then
        area = v
        break
      end
    end
    area = areas[area] or nil
  end
  for k, v in pairs(rooms) do
    if string.lower(v) ~= string.lower(name) then
      rooms[k] = nil
    elseif area and getRoomArea(k) ~= area then
      rooms[k] = nil
    end
  end
  return rooms
end

local function getRoomStubs(roomID)
  -- turns stub info into table similar to exit table
  local stubs = getExitStubs(roomID)
  if type(stubs) ~= 'table' then
    stubs = {}
  end
  -- check handling of custom exits here
  local tmp
  for i = 11, #stubmap do
    tmp = tonumber(getRoomUserData(roomID, 'stub' .. stubmap[i]))
    if tmp then
      table.insert(stubs, tmp)
    end
  end

  local exits = {}
  for k, v in pairs(stubs) do
    exits[stubmap[v]] = 0
  end
  return exits
end

local function connect_rooms(ID1, ID2, dir1, dir2, no_check)
  -- makes a connection between rooms
  -- can make backwards connection without a check
  local match = false
  if not ID1 and ID2 and dir1 then
    error('Connect Rooms: Missing Required Arguments.', 2)
  end
  dir2 = dir2 or reverse_dirs[dir1]
  -- check handling of custom exits here
  if stubmap[dir1] &lt;= 12 then
    setExit(ID1, ID2, stubmap[dir1])
  else
    setRoomUserData(ID1, 'exit ' .. dir1, ID2)
  end
  if stubmap[dir1] &gt; 10 then
    -- check handling of custom exits here
    setRoomUserData(ID1, 'stub' .. dir1, '')
  end
  if mmp.settings.mode ~= 'complex' then
    local stubs = getRoomStubs(ID2)
    if stubs[dir2] then
      match = true
    end
    if (match or no_check) then
      -- check handling of custom exits here
      if stubmap[dir1] &lt;= 12 then
        setExit(ID2, ID1, stubmap[dir2])
      else
        setRoomUserData(ID2, 'exit ' .. dir2, ID1)
      end
      if stubmap[dir2] &gt; 10 then
        -- check handling of custom exits here
        setRoomUserData(ID2, 'stub' .. dir2, '')
      end
    end
  end
end

local function check_room(roomID, name, exits)
  -- check to see if room name and exits match expecations
  if not roomID then
    error('Check Room Error: No ID', 2)
  end
  if name ~= getRoomName(roomID) then
    return false
  end
  if not exits then return true end
  local t_exits = table.union(getRoomExits(roomID), getRoomStubs(roomID))
  -- check handling of custom exits here
  for i = 13, #stubmap do
    t_exits[stubmap[i]] = tonumber(getRoomUserData(roomID, 'exit ' .. stubmap[i]))
  end
  for k, v in ipairs(exits) do
    if short[v] and not table.contains(t_exits, v) then
      return false
    end
    t_exits[v] = nil
  end
  return table.is_empty(t_exits) or check_doors(roomID, t_exits)
end

local function stretch_map(dir, x, y, z)
  -- stretches a mmp to make room for just added room that would overlap with existing room
  local dx, dy, dz
  for k, v in pairs(getAreaRooms(mmp.currentarea)) do
    if v ~= mmp.currentroom then
      dx, dy, dz = getRoomCoordinates(v)
      if dx &gt;= x and string.find(dir, 'east') then
        dx = dx + 1
      elseif dx &lt;= x and string.find(dir, 'west') then
        dx = dx - 1
      end
      if dy &gt;= y and string.find(dir, 'north') then
        dy = dy + 1
      elseif dy &lt;= y and string.find(dir, 'south') then
        dy = dy - 1
      end
      if dz &gt;= z and string.find(dir, 'up') then
        dz = dz + 1
      elseif dz &lt;= z and string.find(dir, 'down') then
        dz = dz - 1
      end
      setRoomCoordinates(v, dx, dy, dz)
    end
  end
end

local function create_room(name, exits, dir, coords)
  -- makes a new room with captured name and exits
  -- links with other rooms as appropriate
  -- links to adjacent rooms in direction of exits if in simple mode
  if mmp.editing then
    echo'\n' mmp.echo('Created New Room: ' .. name)
    local newID = createRoomID()
    addRoom(newID)
    setRoomArea(newID, mmp.currentarea)
    setRoomName(newID, name)
    for k, v in ipairs(exits) do
      if stubmap[v] then
        if stubmap[v] &lt;= 10 then
          setExitStub(newID, stubmap[v], true)
        else
          -- check handling of custom exits here
          setRoomUserData(newID, 'stub' .. v, stubmap[v])
        end
      end
    end
    -- check environment
    if mmp.envids[protocol.environment] then
      setRoomEnv(newID, mmp.envids[protocol.environment])
      mmp.echo('Set room environment to: ' .. protocol.environment)
    end
    -- check indoors status
    if protocol.indoors and getRoomUserData(newID, &quot;indoors&quot;) == '' then
      setRoomUserData(newID, &quot;indoors&quot;, &quot;y&quot;)
      mmp.echo(&quot;Set room to be indoors.&quot;)
    end
    if not (mmp.currentareaname == protocol.area) and not mmp.ignore_area_diff then
      mmp.echo(&quot;We've entered a new area: &quot; .. protocol.area)
    end
    echo'\n'
    if dir then connect_rooms(mmp.currentroom, newID, dir) end
    setRoomCoordinates(newID, unpack(coords))
    local stretched = false
    if mmp.settings.stretchmap and table.size(getRoomsByPosition(mmp.currentarea, unpack(coords))) &gt; 1 then
      speedwalking(newID); stretched = true
      stretch_map(dir, unpack(coords))
    end
    if mmp.settings.mode == 'simple' then
      local x, y, z = unpack(coords)
      local dx, dy, dz, rooms
      for k, v in ipairs(exits) do
        if v ~= dir then
          dx, dy, dz = unpack(coordmap[stubmap[v]])
          rooms = getRoomsByPosition(mmp.currentarea, x + dx, y + dy, z + dz)
          if table.size(rooms) == 1 then
            connect_rooms(newID, rooms[0], v)
          end
        end
      end
    end
    if not stretched then speedwalking(newID) end
  end
end

local function find_area_limits(areaID)
  -- used to find min and max coordinate limits for an area
  if not areaID then
    error('Find Limits: Missing area ID', 2)
  end
  local rooms = getAreaRooms(areaID)
  local minx, miny, minz = getRoomCoordinates(rooms[0])
  local maxx, maxy, maxz = minx, miny, minz
  local x, y, z
  for k, v in pairs(rooms) do
    x, y, z = getRoomCoordinates(v)
    minx = math.min(x, minx)
    maxx = math.max(x, maxx)
    miny = math.min(y, miny)
    maxy = math.max(y, maxy)
    minz = math.min(z, minz)
    maxz = math.max(z, maxz)
  end
  return minx, maxx, miny, maxy, minz, maxz
end

local function find_link(name, exits, dir, max_distance)
  -- search for matching room in desired direction
  local x, y, z = getRoomCoordinates(mmp.currentroom)
  if mmp.editing and x then
    local dx, dy, dz = unpack(coordmap[stubmap[dir]])
    local minx, maxx, miny, maxy, minz, maxz = find_area_limits(mmp.currentarea)
    local rooms, match, stubs
    if max_distance then
      minx = x - max_distance
      maxx = x + max_distance
      miny = y - max_distance
      maxy = y + max_distance
      minz = z - max_distance
      maxz = z + max_distance
    end
    repeat
      x = x + dx
      y = y + dy
      z = z + dz
      rooms = getRoomsByPosition(mmp.currentarea, x, y, z)
    until (x &gt; maxx or x &lt; minx or y &gt; maxy or y &lt; miny or z &gt; maxz or z &lt; minz or not table.is_empty(rooms))
    for k, v in pairs(rooms) do
      if check_room(v, name, exits) then
        match = v
        break
      end
    end
    if match then
      connect_rooms(mmp.currentroom, match, dir)
      speedwalking(match)
    else
      x, y, z = getRoomCoordinates(mmp.currentroom)
      create_room(name, exits, dir, {x + dx, y + dy, z + dz})
    end
  end
end

local function move_map()
  -- tries to move the mmp to the next room
  local move = table.remove(mmp.move_queue, 1)
  if move or random_move then
    local exits = (mmp.currentroom and getRoomExits(mmp.currentroom)) or {}
    -- check handling of custom exits here
    if mmp.currentroom then
      for i = 13, #stubmap do
        exits[stubmap[i]] = tonumber(getRoomUserData(mmp.currentroom, 'exit ' .. stubmap[i]))
      end
    end
    local special = (mmp.currentroom and getSpecialExitsSwap(mmp.currentroom)) or {}
    if move and not exits[move] and not special[move] then
      for k, v in pairs(special) do
        if string.starts(k, move) then
          move = k
          break
        end
      end
    end

    if exits[move] and (check_room(exits[move], mmp.currentroomname) or move:starts('sprint')) then
      speedwalking(exits[move])
    elseif special[move] and (check_room(special[move], mmp.currentroomname)) then
      speedwalking(special[move])
    else
      if mmp.editing and move then
        find_link(mmp.currentroomname, mmp.currentexits, move)
      else
        mmp.find_me(mmp.currentroomname, mmp.currentexits, move)
      end
    end
  end
end

local function capture_move_cmd(dir, priority)
  -- captures valid movement commands
  dir = string.lower(dir)
  if table.contains(exitmap, dir) or dir:starts('sprint ') then
    if priority then
      table.insert(mmp.move_queue, 1, exitmap[dir] or dir)
    else
      table.insert(mmp.move_queue, exitmap[dir] or dir)
    end
  elseif mmp.currentroom then
    local special = getSpecialExitsSwap(mmp.currentroom) or {}
    if special[dir] then
      if priority then
        table.insert(mmp.move_queue, 1, dir)
      else
        table.insert(mmp.move_queue, dir)
      end
    end
  end
end

local function capture_room_exits(exits)
  if mmp.currentroom and getRoomName(mmp.currentroom) == protocol.room and getDoors(mmp.currentroom) then
    local doors = getDoors(mmp.currentroom)
    for dir, stat in pairs(exits) do
      if doors[dir] ~= stat then
        mmp.set_door(dir, stat)
      end
    end
  end
end

local function keystolist(t)
  local r = {}

  for k,_ in pairs(t) do
    r[#r+1] = k
  end

  return r
end

local function capture_room_info(name, exits)
  -- captures room info, and tries to move mmp to match
  if name and exits then
    mmp.previousname = mmp.currentroomname
    mmp.previousexits = mmp.currentexits
    mmp.currentroomname = name
    mmp.currentexits = keystolist(exits) or {}
    move_map()
  end
end

local function find_area(name)
  -- searches for the named area, and creates it if necessary
  local areas = getAreaTable()
  local areaID
  for k, v in pairs(areas) do
    if string.lower(name) == string.lower(k) then
      areaID = v
      break
    end
  end
  if not areaID then
    areaID = addAreaName(name)
  end
  if not areaID then
    error('Invalid Area. No such area found, and area could not be added.')
  end
  mmp.currentarea = areaID
end

function mmp.set_exit(dir, roomID)
  -- used to set unusual exits from the room you are standing in
  if mmp.editing then
    roomID = assert(tonumber(roomID), 'Set Exit: Invalid Room ID')
    if not table.contains(exitmap, dir) and not string.start(dir, '-p ') then
      error('Set Exit: Invalid Direction')
    end

    if not string.start(dir, '-p ') then
      local exit
      if stubmap[exitmap[dir] or dir] &lt;= 12 then
        exit = short[exitmap[dir] or dir]
        setExit(mmp.currentroom, roomID, exit)
      else
        -- check handling of custom exits here
        exit = exitmap[dir] or dir
        exit = 'exit ' .. exit
        setRoomUserData(mmp.currentroom, exit, roomID)
      end
      mmp.echo('Exit ' .. dir .. ' now goes to roomID ' .. roomID)
    else
      dir = string.gsub(dir, '^-p ', '')
      addSpecialExit(mmp.currentroom, roomID, dir)
      mmp.echo(&quot;Special exit '&quot; .. dir .. &quot;' now goes to roomID &quot; .. roomID)
    end
  end
end

function mmp.find_path(roomName, areaName, return_tables)
  areaName = (areaName ~= '' and areaName) or nil
  local rooms = find_room(roomName, areaName)
  local found, dirs = false, {}
  local path = {}
  for k, v in pairs(rooms) do
    found = getPath(mmp.currentroom, k)
    if found and (#dirs == 0 or #dirs &gt; #speedWalkDir) then
      dirs = speedWalkDir
      path = speedWalkPath
    end
  end
  if return_tables then
    if table.is_empty(path) then
      path, dirs = nil, nil
    end
    return path, dirs
  else
    if #dirs &gt; 0 then
      mmp.echo('Path to ' .. roomName .. ((areaName and ' in ' .. areaName) or '') .. ': ' .. table.concat(dirs, ', '))
    else
      mmp.echo('No path found to ' .. roomName .. ((areaName and ' in ' .. areaName) or '') .. '.')
    end
  end
end

function mmp.start_mapping(area_name)
  -- starts mmp.editing, and sets the current area to the given one, or uses the current one
  if not mmp.currentroomname then
    mmp.echo('Start Mapping Error: No room detected!')
    error('Start Mapping Error: No room detected!')
  end
  local rooms
  mmp.move_queue = {}
  area_name = area_name ~= '' and area_name or nil
  if mmp.currentarea and not area_name then
    local areas = getAreaTableSwap()
    area_name = areas[mmp.currentarea]
  end
  if not area_name then
    mmp.echo('Start Mapping Error: No area set!')
    error('Start Mapping Error: No area set!')
  end
  mmp.echo('Now mapping in area: ' .. area_name)
  find_area(area_name)
  rooms = find_room(mmp.currentroomname, mmp.currentarea)
  if table.is_empty(rooms) then
    if mmp.currentroom and table.contains(getRooms(), protocol.room) then
      mmp.set_area(area_name)
    else
      create_room(mmp.currentroomname, mmp.currentexits, nil, {0, 0, 0})
    end
  elseif mmp.currentroom and mmp.currentarea ~= getRoomArea(mmp.currentroom) then
    mmp.set_area(area_name)
  end
end

function mmp.clear_moves()
  mmp.move_queue = {}
  mmp.echo('Move queue cleared.')
end

function mmp.set_area(name)
  -- assigns the current room to the area given, creates the area if necessary
  if mmp.editing then
    find_area(name)
    if mmp.currentroom and getRoomArea(mmp.currentroom) ~= mmp.currentarea then
      setRoomArea(mmp.currentroom, mmp.currentarea)
      speedwalking(mmp.currentroom)
    end
  end
end

function mmp.set_door(dir, status, one_way)
  -- adds a door on a given exit
  if not mmp.currentroom then
    error('Make Door: No room found.')
  end
  dir = exitmap[dir] or dir
  if not stubmap[dir] then
    error('Make Door: Invalid direction.')
  end
  status = (status ~= '' and status) or 'closed'
  one_way = (one_way ~= '' and one_way) or 'no'
  if not table.contains({'yes', 'no'}, one_way) then
    error('Make Door: Invalid one-way status, must be yes or no.')
  end

  local exits = getRoomExits(mmp.currentroom)
  local exit
  -- check handling of custom exits here
  for i = 13, #stubmap do
    exit = 'exit ' .. stubmap[i]
    exits[stubmap[i]] = tonumber(getRoomUserData(mmp.currentroom, exit))
  end
  local target_room = exits[dir]
  if target_room then
    exits = getRoomExits(target_room)
    -- check handling of custom exits here
    for i = 13, #stubmap do
      exit = 'exit ' .. stubmap[i]
      exits[stubmap[i]] = tonumber(getRoomUserData(target_room, exit))
    end
  end
  if one_way == 'no' and (target_room and exits[reverse_dirs[dir]] == mmp.currentroom) then
    add_door(target_room, reverse_dirs[dir], status)
  end
  add_door(mmp.currentroom, dir, status)
end

function mmp.shift_room(dir)
  -- shifts a room around on the mmp
  if mmp.editing then
    dir = assert(exitmap[dir] or (table.contains(exitmap, dir) and dir), 'Exit Not Found')
    local x, y, z = getRoomCoordinates(mmp.currentroom)
    dir = stubmap[dir]
    local coords = coordmap[dir]
    x = x + coords[1]
    y = y + coords[2]
    z = z + coords[3]
    setRoomCoordinates(mmp.currentroom, x, y, z)
    centerview(mmp.currentroom)
  end
end

local function check_link(firstID, secondID, dir)
  -- check to see if two rooms are connected in a given direction
  if not firstID then
    error('Check Link Error: No first ID', 2)
  end
  if not secondID then
    error('Check Link Error: No second ID', 2)
  end
  local name = getRoomName(firstID)
  local exits1 = table.union(getRoomExits(firstID), getRoomStubs(firstID))
  local exits2 = table.union(getRoomExits(secondID), getRoomStubs(secondID))
  local exit
  -- check handling of custom exits here
  for i = 13, #stubmap do
    exit = 'exit ' .. stubmap[i]
    exits1[stubmap[i]] = tonumber(getRoomUserData(firstID, exit))
    exits2[stubmap[i]] = tonumber(getRoomUserData(secondID, exit))
  end
  local checkID = exits2[reverse_dirs[dir]]
  local exits = {}
  for k, v in pairs(exits1) do
    table.insert(exits, k)
  end
  return checkID and check_room(checkID, name, exits)
end

function mmp.find_me(name, exits, dir)
  -- tries to locate the player using the current room name and exits, and if provided, direction of movement
  -- if direction of movement is given, narrows down possibilities using previous room info
  local check = dir and mmp.currentroom and table.contains(exitmap, dir)
  name = name or mmp.currentroomname
  exits = exits or mmp.currentexits
  local rooms = find_room(name)
  local match_IDs = {}
  for k, v in pairs(rooms) do
    if check_room(k, name, exits) then
      table.insert(match_IDs, k)
    end
  end
  rooms = match_IDs
  match_IDs = {}
  if table.size(rooms) &gt; 1 and check then
    for k, v in pairs(rooms) do
      if check_link(mmp.currentroom, v, dir) then
        table.insert(match_IDs, v)
      end
    end
  elseif random_move then
    for k, v in pairs(getRoomExits(mmp.currentroom)) do
      if check_room(v, mmp.currentroomname, mmp.currentexits) then
        table.insert(match_IDs, v)
      end
    end
  end
  if table.size(match_IDs) == 0 then
    match_IDs = rooms
  end
  if not table.is_empty(match_IDs) then
    speedwalking(match_IDs[1])
  end
end

function mmp.merge_rooms()
  -- used to combine essentially identical rooms with the same coordinates
  -- typically, these are generated due to mmp.editing errors
  if mmp.editing then
    local x, y, z = getRoomCoordinates(mmp.currentroom)
    local rooms = getRoomsByPosition(mmp.currentarea, x, y, z)
    local exits, portals, room, cmd, curportals
    for k, v in pairs(rooms) do
      if v ~= mmp.currentroom then
        if getRoomName(v) == getRoomName(mmp.currentroom) then
          for k1, v1 in pairs(getRoomExits(v)) do
            setExit(mmp.currentroom, v1, stubmap[k1])
            exits = getRoomExits(v1)
            if exits[reverse_dirs[k1]] == v then
              setExit(v1, mmp.currentroom, stubmap[reverse_dirs[k1]])
            end
          end
          for k1, v1 in pairs(getDoors(v)) do
            setDoor(mmp.currentroom, k1, v1)
          end
          for k1, v1 in pairs(getSpecialExitsSwap(v)) do
            addSpecialExit(mmp.currentroom, v1, k1)
          end
          -- check handling of custom exits here for doors and exits, and reverse exits
          for i = 9, #stubmap do
            local door = 'door ' .. stubmap[i]
            local tmp = tonumber(getRoomUserData(v, door))
            if tmp then
              setRoomUserData(mmp.currentroom, door, tmp)
            end
            local exit = 'exit ' .. stubmap[i]
            tmp = tonumber(getRoomUserData(v, exit))
            if tmp then
              setRoomUserData(mmp.currentroom, exit, tmp)
              if tonumber(getRoomUserData(tmp, 'exit ' .. reverse_dirs[stubmap[i]])) == v then
                setRoomUserData(tmp, exit, mmp.currentroom)
              end
            end
          end
          deleteRoom(v)
        end
      end
    end
  end
end

function mmp.eventHandler(event, ...)
  if event == 'onPrompt' and room_detected then
    room_detected, exits_detected = false, false
    capture_room_info(protocol.room, protocol.exits)
  elseif event == 'onPrompt' and exits_detected then
    exits_detected = false
    capture_room_exits(protocol.exits)
  elseif event == 'onMoveFail' then
    table.remove(mmp.move_queue, 1)
  elseif event == 'onRandomMove' then
    random_move = true
    mmp.move_queue = {}
  elseif event == 'onForcedMove' then
    capture_move_cmd(arg[1], arg[2] == 'true')
  elseif event == 'onNewRoom' then
    room_detected = true
    protocol.exits = {} -- sometimes it doesn't get updated
  elseif event == 'onNewExits' then
    exits_detected = true
  elseif event == 'sysDataSendRequest' then
    capture_move_cmd(arg[1])
  end
end

registerAnonymousEventHandler('sysDataSendRequest', 'mmp.eventHandler')
registerAnonymousEventHandler('onPrompt', 'mmp.eventHandler')
registerAnonymousEventHandler('onMoveFail', 'mmp.eventHandler')
registerAnonymousEventHandler('onRandomMove', 'mmp.eventHandler')
registerAnonymousEventHandler('onForcedMove', 'mmp.eventHandler')
registerAnonymousEventHandler('onNewRoom', 'mmp.eventHandler')
registerAnonymousEventHandler('onNewExits', 'mmp.eventHandler')</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>special exits</name>
                <packageName></packageName>
                <script></script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>fixSpecialExits</name>
                    <packageName></packageName>
                    <script>-- a certain version of the mapper gave us special exits prepended with 0 or 1 in the command
-- depending on if it was locked. Need to remove these before we can use them
function mmp.fixSpecialExits(directions)
  for i = 1, #directions do
    if directions[i]:match('^%d') then
      directions[i] = directions[i]:sub(2)
    end
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>clearspecials</name>
                    <packageName></packageName>
                    <script>-- cleanup function to remove the temp special exit we made - only way to remove specials in Mudlet atm is by clearing them all
function mmp.clearspecials(ignorerooms)
  local t = getSpecialExits(mmp.currentroom)
  clearSpecialExits(mmp.currentroom)

  for connectingroom, exits in pairs(t) do
    if not table.contains(ignorerooms, connectingroom) then -- don't re-add this one back as it's our temp
      for command, locked in pairs(exits) do
        --debug echo: mmp.echo(&quot;need to re-link this room to &quot;..connectingroom..&quot; with &quot;..command..&quot; that is &quot;..(locked == &quot;1&quot; and &quot;locked&quot; or &quot;unlocked&quot;)..&quot;.&quot;)
        addSpecialExit(mmp.currentroom, connectingroom, command)
        if locked == '1' then
          lockSpecialExit(mmp.currentroom, connectingroom, command, true)
        end
      end
    end
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>listSpecialExits</name>
                    <packageName></packageName>
                    <script>function mmp.listSpecialExits(filter)
  local c = 0

  mmp.echo('Listing special exits...')
  for area, areaname in pairs(mmp.areatabler) do
    local rooms = getAreaRooms(area) or {}
    for i = 0, #rooms do
      local exits = getSpecialExits(rooms[i] or 0)

      if exits and next(exits) then
        for exit, cmd in pairs(exits) do
          if type(cmd) == 'table' then
            cmd = next(cmd)
          end
          if cmd:match('^%d') then
            cmd = cmd:sub(2)
          end

          if not filter or cmd:lower():find(filter, 1, true) then
            if getRoomArea(exit) ~= area then
              cecho(string.format('&lt;dark_slate_grey&gt;%s &lt;LightSlateGray&gt;(%d, in %s)&lt;dark_slate_grey&gt; &lt;MediumSlateBlue&gt;-&gt; &lt;coral&gt;%s -&lt;MediumSlateBlue&gt;&gt;&lt;dark_slate_grey&gt; %s &lt;LightSlateGray&gt;(%d, in %s)\n', getRoomName(rooms[i]), rooms[i], areaname, cmd, getRoomName(exit), exit, mmp.areatabler[getRoomArea(exit)] or '?'))
            else
              cecho(string.format('&lt;dark_slate_grey&gt;%s &lt;LightSlateGray&gt;(%d)&lt;dark_slate_grey&gt; &lt;MediumSlateBlue&gt;-&gt; &lt;coral&gt;%s &lt;MediumSlateBlue&gt;-&gt;&lt;dark_slate_grey&gt; %s &lt;LightSlateGray&gt;(%d)&lt;dark_slate_grey&gt; in %s\n', getRoomName(rooms[i]), rooms[i], cmd, getRoomName(exit), exit, areaname))
            end
            c = c + 1
          end
        end
      end
    end
  end

  mmp.echo(string.format('%d exits listed%s.', c, (not filter and '' or &quot;, with for the filter '&quot; .. filter .. &quot;'&quot;)))
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>delSpecialExits</name>
                    <packageName></packageName>
                    <script>function mmp.delSpecialExits(filter)
  local c = 0
  for area, areaname in pairs(mmp.areatabler) do
    local rooms = getAreaRooms(area) or {}
    for i = 0, #rooms do
      local exits = getSpecialExits(rooms[i] or 0)

      if exits and next(exits) then
        for exit, cmd in pairs(exits) do
          if type(cmd) == 'table' then
            cmd = next(cmd)
          end
          if cmd:match('^%d') then
            cmd = cmd:sub(2)
          end

          if not filter or cmd:lower():find(filter, 1, true) then
            local rid, action
            local originalExits = {}
            local e = getSpecialExits(rooms[i])
            for t, n in pairs(e) do
              rid = tonumber(t)
              for a, l in pairs(n) do
                action = tostring(a)
              end
              if not action:find(filter, 1, true) then
                originalExits[rid] = action
              end
            end
            clearSpecialExits(rooms[i])
            for rid, act in pairs(originalExits) do
              addSpecialExit(rooms[i], tonumber(rid), tostring(act))
            end
            c = c + 1
          end
        end
      end
    end
  end

  mmp.echo(string.format('%d exits deleted%s.', c, (not filter and '' or &quot;, with for the filter '&quot; .. filter .. &quot;'&quot;)))
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>fix setexit</name>
                    <packageName></packageName>
                    <script>do
  local oldsetExit = setExit

  local exitmap = {
    n = 1,
    north = 1,
    ne = 2,
    northeast = 2,
    nw = 3,
    northwest = 3,
    e = 4,
    east = 4,
    w = 5,
    west = 5,
    s = 6,
    south = 6,
    se = 7,
    southeast = 7,
    sw = 8,
    southwest = 8,
    u = 9,
    up = 9,
    d = 10,
    down = 10,
    ['in'] = 11,
    out = 12
  }

  function setExit(from, to, direction)
    if type(direction) == 'string' and not exitmap[direction] then
      return false
    end

    return oldsetExit(from, to, type(direction) == 'string' and exitmap[direction] or direction)
  end
end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>locking</name>
                <packageName></packageName>
                <script></script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>doLock</name>
                    <packageName></packageName>
                    <script>function mmp.doLock(what, lock, filter)
  if what then
    mmp.echo(string.format('%s all %s...', (lock and 'Locking' or 'Unlocking'), what))
  end
  local c = 0

  local getAreaRooms, getSpecialExits, lockSpecialExit, next = getAreaRooms, getSpecialExits, lockSpecialExit, next
  for _, area in pairs(getAreaTable()) do
    local rooms = getAreaRooms(area) or {}
    for i = 0, #rooms do
      local exits = getSpecialExits(rooms[i] or 0)

      if exits and next(exits) then
        for exit, cmd in pairs(exits) do
          if type(cmd) == 'table' then
            cmd = next(cmd)
          end

          if (not filter and not (cmd:lower():find('pathfind', 1, true) or cmd:lower():find('worm warp', 1, true) or cmd:lower():find('enter grate', 1, true))) or (filter and cmd:lower():find(filter, 1, true)) then
            lockSpecialExit(rooms[i], exit, cmd, lock)
            c = c + 1
          end
        end
      end
    end
  end

  if what then
    mmp.echo(string.format('%s %s known %s.', (lock and 'Locked' or 'Unlocked'), c, what))
  end
  return c
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>lockSpecials</name>
                    <packageName></packageName>
                    <script>function mmp.lockSpecials()
  local lock = mmp.settings.lockspecials and true or false
  mmp.doLock('special exits', lock)
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>fix exit locking funcs</name>
                    <packageName></packageName>
                    <script>do
  local oldlockExit = lockExit
  local oldhasExitLock = hasExitLock

  local exitmap = {
    n = 1,
    north = 1,
    ne = 2,
    northeast = 2,
    nw = 3,
    northwest = 3,
    e = 4,
    east = 4,
    w = 5,
    west = 5,
    s = 6,
    south = 6,
    se = 7,
    southeast = 7,
    sw = 8,
    southwest = 8,
    u = 9,
    up = 9,
    d = 10,
    down = 10,
    ['in'] = 11,
    out = 12
  }

  function lockExit(from, direction, status)
    if type(direction) == 'string' and not exitmap[direction] then
      return false
    end

    return oldlockExit(from, type(direction) == 'string' and exitmap[direction] or direction, status)
  end

  function hasExitLock(from, direction)
    if type(direction) == 'string' and not exitmap[direction] then
      return false
    end

    return oldhasExitLock(from, type(direction) == 'string' and exitmap[direction] or direction)
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>lock area</name>
                    <packageName></packageName>
                    <script>-- Lock Area

mmp.locked = mmp.locked or {}
mmp.lastLockSearch = mmp.lastLockSearch or nil

function mmp.doLockArea(search)
  local areaList
  if search ~= nil then
    local r = rex.new(string.lower(search))
    mmp.lastLockSearch = search
    for name, id in pairs(getAreaTable()) do
      if r:match(string.lower(name)) then
        areaList = areaList or {}
        areaList[name] = id
      end
    end
    if areaList == nil then
      mmp.echo(&quot;'&quot; .. search .. &quot;' did not match any known areas!&quot;)
      return
    end
  else
    mmp.lastLockSearch = nil
    areaList = getAreaTable()
  end

  for name, id in pairs(areaList) do
    mmp.echon(name .. string.rep(' ', 40 - string.len(name)))
    if not mmp.locked[id] then
      setFgColor(0, 200, 0)
      setUnderline(true)
      echoLink('Lock!', [[mmp.lockArea( ']] .. name:gsub(&quot;'&quot;, [[\']]) .. [[', true )]], &quot;Click to lock area '&quot; .. name .. &quot;'&quot;, true)
    else
      setFgColor(200, 0, 0)
      setUnderline(true)
      echoLink('Unlock!', [[mmp.lockArea( ']] .. name:gsub(&quot;'&quot;, [[\']]) .. [[', false )]], &quot;Click to unlock area '&quot; .. name .. &quot;'&quot;, true)
    end
  end

  if not search then
    echo '\n\n'
    mmp.echo('Use &lt;green&gt;arealock &lt;area&gt;&lt;white&gt; to filter areas.')
  end
end

function mmp.lockArea(name, lock, dontreshow)
  local areas = getAreaTable()
  local rooms = getAreaRooms(areas[name]) or {}
  local lockRoom = lockRoom
  local count = 0
  for _, room in pairs(rooms) do
    lockRoom(room, lock)
    count = count + 1
  end

  mmp.locked[areas[name]] = lock and true or nil
  mmp.echo(string.format(&quot;Area '%s' %slocked! All %s room%s within it.&quot;, name, (lock and '' or 'un'), count, (count == 1 and '' or 's')))

  if not dontreshow then
    mmp.doLockArea(mmp.lastLockSearch)
  end
end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>utilities</name>
                <packageName></packageName>
                <script></script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>changeBoolFunc</name>
                    <packageName></packageName>
                    <script>function mmp.changeBoolFunc(name, option)
  local en
  if option then
    en = 'will now use'
  else
    en = 'will no longer use'
  end
  mmp.echo('&lt;green&gt;Okay, the mapper ' .. en .. ' &lt;white&gt;' .. name .. '&lt;green&gt;!')
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>direction-translating functions</name>
                    <packageName></packageName>
                    <script>-- translates n to north and so forth
local temp = {
  n = 'north',
  e = 'east',
  s = 'south',
  w = 'west',
  ne = 'northeast',
  se = 'southeast',
  sw = 'southwest',
  nw = 'northwest',
  u = 'up',
  d = 'down',
  i = 'in',
  o = 'out',
  ['in'] = 'in'
}
local anytolongmap = {}
for s, l in pairs(temp) do
  anytolongmap[l] = l
  anytolongmap[s] = l
end
function mmp.anytolong(exit)
  return anytolongmap[exit]
end

function mmp.anytoshort(exit)
  local t = {
    n = 'north',
    e = 'east',
    s = 'south',
    w = 'west',
    ne = 'northeast',
    se = 'southeast',
    sw = 'southwest',
    nw = 'northwest',
    u = 'up',
    d = 'down',
    ['in'] = 'in',
    out = 'out'
  }
  local rt = {}
  for s, l in pairs(t) do
    rt[l] = s
    rt[s] = s
  end

  return rt[exit]
end

function mmp.ranytolong(exit)
  local t = {
    n = 'south',
    north = 'south',
    e = 'west',
    east = 'west',
    s = 'north',
    south = 'north',
    w = 'east',
    west = 'east',
    ne = 'southwest',
    northeast = 'southwest',
    se = 'northwest',
    southeast = 'northwest',
    sw = 'northeast',
    southwest = 'northeast',
    nw = 'southeast',
    northwest = 'southeast',
    u = 'down',
    up = 'down',
    d = 'up',
    down = 'up',
    i = 'out',
    ['in'] = 'out',
    o = 'in',
    out = 'in'
  }

  return t[exit]
end

-- returns nil or the room number relative to this one
function mmp.relativeroom(from, dir)
  if not mmp.roomexists(from) then
    return
  end

  local exits = getRoomExits(tonumber(from))
  return exits[mmp.anytolong(dir)]
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>indexof_valueonly</name>
                    <packageName></packageName>
                    <script>function mmp.indexof_valueonly(data, value)
  for i = 1, #data do
    if data[i] == value then
      return i
    end
  end

  return false
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>comma_value</name>
                    <packageName></packageName>
                    <script>function mmp.comma_value(n) -- credit http://richard.warburton.it
  local left, num, right = string.match(n, '^([^%d]*%d)(%d*)(.-)$')
  return left .. (num:reverse():gsub('(%d%d%d)', '%1,'):reverse()) .. right
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="no" isFolder="no">
                    <name>mmp_grabenvid</name>
                    <packageName></packageName>
                    <script>function mmp_grabenvid()
  if not mmp.envids[protocol.environment] then
    mmp.envids[protocol.environment] = getRoomEnv(mmp.currentroom)
    mmp.echo(string.format('Remembered environment %s as %d', protocol.environment, mmp.envids[protocol.environment]))
  end
end

function mmp.getMaxID()
  local roomIDs = {}
  for area, _ in pairs(mmp.areatabler) do
    local ok, t = pcall(getAreaRooms, area)
    if ok then
      for _, id in pairs(t or {}) do
        roomIDs[id] = true
      end
    end
  end

  return table.maxn(roomIDs)
end

function mmp.getUnknownEnvs()
  local maxid, missing = mmp.getMaxID(), {}

  for i = 1, maxid do
    if mmp.roomexists(i) then
      if not table.contains(mmp.envids, getRoomEnv(i)) and not table.contains(missing, getRoomEnv(i)) then
        mmp.echo(string.format(&quot;Missing env %d from room %d ('%s' in '%s')&quot;, tostring(getRoomEnv(i)), i, tostring(getRoomName(i)), tostring(mmp.areatabler[getRoomArea(i)])))
        missing[i] = getRoomEnv(i)
      end
    end
  end
end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>api</name>
                <packageName></packageName>
                <script></script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>echos</name>
                    <packageName></packageName>
                    <script>function mmp.echo(what)
  what = what or ''
  moveCursorEnd('main')
  if getCurrentLine() ~= '' then
    echo '\n'
  end
  decho('&lt;112,229,0&gt;(&lt;73,149,0&gt;mapper&lt;112,229,0&gt;): &lt;255,255,255&gt;')
  cecho(tostring(what))
  echo('\n')
end

function mmp.echon(what)
  moveCursorEnd('main')
  if getCurrentLine() ~= '' then
    echo '\n'
  end
  decho('&lt;112,229,0&gt;(&lt;73,149,0&gt;mapper&lt;112,229,0&gt;): &lt;255,255,255&gt;')
  cecho(tostring(what))
end

function mmp.changeEchoColour()
  mmp.echo('Now displaying echos in &lt;' .. mmp.settings.echocolour .. '&gt;' .. mmp.settings.echocolour)
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>pause</name>
                    <packageName></packageName>
                    <script>function mmp.pause(what)
  assert(what == nil or what == 'on' or what == 'off', &quot;mmp.pause wants 'on', 'off' or nothing as an argument&quot;)

  if what == 'on' or (what == nil and not mmp.paused) then
    mmp.paused = true
  elseif what == 'off' or (what == nil and mmp.paused) then
    mmp.paused = false
  end

  mmp.echo('Speedwalking ' .. (mmp.paused and 'paused' or 'unpaused') .. '.')
  if not mmp.paused then
    mmp.move_logic()
  end
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>mapLook</name>
                    <packageName></packageName>
                    <script>function mmp.mapLook(roomid, delay)
  centerview(roomid)
  if mmp.maplooktimer then
    killTimer(mmp.maplooktimer)
  end
  mmp.maplooktimer = tempTimer(tonumber(delay) or 4, [[centerview(mmp.currentroom); mmp.maplooktimer = nil]])
end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>check for map updates</name>
                <packageName></packageName>
                <script></script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>mmp_downloaded_file</name>
                    <packageName></packageName>
                    <script>function mmp_downloaded_file(_, filename)
  if not io.exists(filename) then
    return
  end

  if filename == tostring(mmp.mapperfile) then -- mapper script version
    mmp.checkingupdates = false

    local f, s = io.open(filename)
    if f then
      s = f:read('*l'):trim()
      io.close(f)
    end

    if s ~= tostring(mmp.version) then
      mmp.newmapperversion = s
      mmp.retrievechangelog()
    end
  elseif filename == tostring(mmp.changelogfile) then -- changelog for the mapper script
    mmp.checkingupdates = false

    local f, s, changelog = io.open(filename)
    if f then
      changelog = f:read('*a')
      io.close(f)
    end

    mmp.echon('')
    echoLink('The mapper script was updated! Would you like to download the update? Click here if so.', 'mmp.downloadmapperscript()', 'Changelog for the latest (' .. tostring(mmp.version) .. ' -&gt; ' .. tostring(mmp.newmapperversion) .. ') update:\n' .. changelog, true)
  elseif filename == mmp.crowdchangelogfile then -- changelog for the crowdmap
    local f, s = io.open(filename)
    if f then
      s = f:read('*a')
      io.close(f)
    end

    -- CROWD MAPS ARE NOT IMPLEMENTED - Maybe in the future though, eh?

    -- make environment
    local env = {} -- add functions you know are safe here

    -- run code under environment [Lua 5.1]
    local function run(untrusted_code)
      if untrusted_code:byte(1) == 27 then
        return nil, 'binary bytecode prohibited'
      end
      local untrusted_function, message = loadstring(untrusted_code)
      if not untrusted_function then
        return nil, message
      end
      setfenv(untrusted_function, env)
      return pcall(untrusted_function)
    end

    run(s)

    mmp.crowdchangelog = env.changelog

    mmp.echon('The crowdmap map was ')
    setUnderline(true)
    echoLink('updated', '', 'New version: ' .. tostring(mmp.newversion) .. ', previous version: ' .. (mmp.oldversion or '(none)'), true)
    setUnderline(false)
    echo(' (')
    setUnderline(true)
    echoLink('see full changelog', 'mmp.showcrowdchangelog()', 'View the full changelog for mappers', true)
    setUnderline(false)
    echo('). Latest improvement is: ' .. tostring(mmp.crowdchangelog and mmp.crowdchangelog[#mmp.crowdchangelog] or '?') .. '.\n')

    mmp.downloadcrowdmap(mmp.newversion)
  elseif filename == mmp.crowdmapfile then -- crowdmap map
    mmp.echo('Map downloaded, loading it in...')

    local tmp = getRoomUserData(1, 'gotoMapping')
    local oldmaptable = {}

    if tmp ~= '' then
      oldmaptable = yajl.to_value(tmp)
    end

    local ok = loadMap(filename)

    if ok then
      if mmp.settings.waterwalk then
        mmp.enableWaterWalk()
      else
        mmp.disableWaterWalk()
      end

      mmp.echo('Map loaded fine - enjoy!')

      tmp = getRoomUserData(1, 'gotoMapping')
      local newmaptable = {}

      if tmp ~= '' then
        newmaptable = yajl.to_value(tmp)
      end

      for k, v in pairs(oldmaptable) do
        newmaptable[k] = v
      end
      setRoomUserData(1, 'gotoMapping', yajl.to_string(newmaptable))
      mmp.echo('Marks from the old map migrated successfully.')

      raiseEvent('mmapper updated map')
    else
      mmp.echon('Map failed to load - you need to have the mapper open. Please open it, and then ')
      echoLink('click here', [[
        local tmp = getRoomUserData(1, &quot;gotoMapping&quot;)
        local oldmaptable = {}
        if tmp ~= &quot;&quot; then
          oldmaptable = yajl.to_value(tmp)
        end

        local ok = loadMap(']] .. filename .. [[')
        if ok then
          if mmp.settings.waterwalk then mmp.enableWaterWalk() else mmp.disableWaterWalk() end

          mmp.echo(&quot;Map loaded successfully!&quot;)

          tmp = getRoomUserData(1, &quot;gotoMapping&quot;)
          local newmaptable = {}
          if tmp ~= &quot;&quot; then
            newmaptable = yajl.to_value(tmp)
          end
          for k,v in pairs(oldmaptable) do newmaptable[k] = v end
          setRoomUserData(1, &quot;gotoMapping&quot;, yajl.to_string(newmaptable))
          mmp.echo(&quot;Marks from the old map migrated successfully.&quot;)
          raiseEvent(&quot;mmapper updated map&quot;)
        else mmp.echo(&quot;Nope, didn't work. Open the map and try again?&quot;) end
      ]], 'Click here to try loading the map again')
      echo(' to try loading it in again.\n')
    end
  elseif filename == tostring(mmp.downloadedscript) then -- new mapper script xml downloaded
    mmp.checkingupdates = false

    mmp.echo(&quot;Your mapper script was downloaded to '&quot; .. filename .. &quot;' - uninstall the current copy and install the new one now!&quot;)
  elseif filename == tostring(mmp.mapfile) then -- map version #, either Avalon's or crowd
    mmp.checkingupdates = false

    local function needupdate(currentmd5, oldmd5)
      if not mmp.settings.crowdmap then
        mmp.echon('The games map was ')
        echoLink('updated', '', 'New MD5: ' .. tostring(currentmd5) .. ', previous MD5: ' .. (oldmd5 or '(none)'), true)
        echo(&quot; - you should update yours! Go to Settings -&gt; Mapper tab and click on the button there. Once you've updated, &quot;)
        echoLink('click here', &quot;mmp.updatedmap('&quot; .. currentmd5 .. &quot;')&quot;, 'Click here to quiet the update reminder')
        echo(' to remove the reminder.')
      else
        mmp.newversion, mmp.oldversion = currentmd5, oldmd5
        mmp.retrievecrowdchangelog()
      end
    end

    local f, s = io.open(filename)
    if f then
      s = f:read('*a')
      io.close(f)
    end
    local currentmd5 = string.match(s, '([a-z0-9]+)  map%.xml')

    -- using crowdsourced map
    if not currentmd5 then
      currentmd5 = s:trim()
    end

    os.remove(filename)

    -- never checked yet?
    if not io.exists(getMudletHomeDir() .. '/map downloads/current') then
      needupdate(currentmd5)
      return
    end

    -- otherwise read old file and check
    local f, s = io.open(getMudletHomeDir() .. '/map downloads/current')
    if f then
      s = f:read('*a')
      io.close(f)
    end

    if s ~= currentmd5 then
      needupdate(currentmd5, s)
    end
  end
end</script>
                    <eventHandlerList>
                        <string>sysDownloadDone</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>check for updates</name>
                    <packageName></packageName>
                    <script>local downloadfolder = getMudletHomeDir() .. '/map downloads/'
local whereisit

-- this should get called at start and every hour after that
function mmp.checkforupdate()
  if not mmp.game or mmp.checkingupdates then
    return
  end

  local game = mmp.game or 'avalon'
  mmp.mapfile = downloadfolder .. 'MD5'
  mmp.mapperfile = downloadfolder .. 'mapper'

  if not downloadFile then
    mmp.echo(&quot;Your version of Mudlet doesn't support downloading files - please upgrade to 2.0+&quot;)
  else
    if not lfs.attributes(downloadfolder) then
      if lfs and lfs.mkdir then
        local t, s = lfs.mkdir(downloadfolder)
        if not t and s ~= 'File exists' then
          mmp.echo(&quot;Couldn't make the '&quot; .. downloadfolder .. &quot;' folder; &quot; .. s)
          return
        end
      else
        mmp.echo(&quot;Sorry, but you need LuaFileSystem (lfs) installed, or have the '&quot; .. downloadfolder .. &quot;' folder exist.&quot;)
        return
      end
    end

    if mmp.settings.crowdmap and mmp.game and mmp.game == 'avalon' then
      -- downloadFile(mmp.mapfile, 'https://macjabeth.github.io/AvalonCrowdmap/Map/version.txt')
    elseif mmp.settings.updatemap then
      downloadFile(mmp.mapfile, 'http://www.avalon-rpg.com/maps/MD5SUM')
    end

    downloadFile(mmp.mapperfile, 'https://macjabeth.github.io/avalon-mapping-script/downloads/version')
    mmp.checkingupdates = true
  end
end

-- called by the user when the map is updated to register the fact that it was
function mmp.updatedmap(currentmd5)
  assert(currentmd5, 'need md5 sum to write to file')

  local f, err = io.open(downloadfolder .. 'current', 'w')
  if not f then
    return mmp.echo(&quot;Couldn't write to the update file, because: &quot; .. err)
  end
  f:write(currentmd5)
  f:close()

  local t = {'Go you for updating!', 'Thanks for updating the map!', 'Alright, map updated!'}
  mmp.echo(t[math.random(1, #t)])
end

-- downloads the latest changelog for the mapper if it was updated
function mmp.retrievechangelog()
  mmp.changelogfile = downloadfolder .. 'changelog'

  downloadFile(mmp.changelogfile, 'https://macjabeth.github.io/avalon-mapping-script/downloads/changelog')
end

function mmp.retrievecrowdchangelog()
  mmp.crowdchangelogfile = downloadfolder .. 'crowdchangelogfile'

  downloadFile(mmp.crowdchangelogfile, 'https://macjabeth.github.io/AvalonCrowdmap/Map/changelog.txt')
end

-- downloads the public crowdsources map!
function mmp.downloadmapperscript()
  local downloadlocationfile = downloadfolder .. 'savepath'
  local downloadlocation
  local exists = lfs.attributes

  -- somewhat complicated thing to nicely deal with all scenarios.
  if not exists(downloadlocationfile) then
    downloadlocation = whereisit()
    if not downloadlocation then
      return
    end
  end

  if not downloadlocation then
    local f, s = io.open(downloadlocationfile)
    if f then
      downloadlocation = f:read('*a')
      io.close(f)
    end

    if not exists(downloadlocation) then
      downloadlocation = whereisit()
      if not downloadlocation or not exists(downloadlocation) then
        return
      end
    end
  end

  mmp.downloadedscript = downloadlocation .. '/avalon-mapper.xml'
  downloadFile(mmp.downloadedscript, 'https://macjabeth.github.io/avalon-mapping-script/downloads/avalon-mapper.xml')

  local f, err = io.open(downloadlocationfile, 'w')
  if not f then
    return mmp.echo(&quot;Couldn't write to the location file, because: &quot; .. err)
  end
  f:write(downloadlocation)
  f:close()
  mmp.echo('Okay, downloading the mapper script...')
end

function mmp.downloadcrowdmap(newversion)
  mmp.crowdmapfile = downloadfolder .. 'crowdmap'

  local f, err = io.open(downloadfolder .. 'current', 'w')
  if not f then
    return mmp.echo(&quot;Couldn't write to the update file, because: &quot; .. err)
  end
  f:write(newversion)
  f:close()

  downloadFile(mmp.crowdmapfile, 'https://macjabeth.github.io/AvalonCrowdmap/Map/map')

  mmp.echo('Downloading the latest crowdmap...')
end

function mmp.showcrowdchangelog()
  mmp.echo('Public map changelog:')

  if not mmp.crowdchangelog then
    mmp.echo('(none yet)')
    return
  end

  for k, v in ipairs(mmp.crowdchangelog) do
    cecho(string.format('  %s) %s\n', k, v:gsub('\t', '     ')))
  end
end

whereisit = function()
  local path = invokeFileDialog(false, 'Where should we save the file? Select a folder and click Open')

  if path == '' then
    return nil
  else
    return path
  end
end</script>
                    <eventHandlerList/>
                    <Script isActive="yes" isFolder="no">
                        <name>mmp_checkupdatestart</name>
                        <packageName></packageName>
                        <script>function mmp_checkupdatestart(...)
  if mmp.checkforupdatetimer then
    killTimer(mmp.checkforupdatetimer)
  end
  mmp.checkforupdatetimer = tempTimer(math.random(3, 10), mmp.checkforupdate)
end

function mmp.changeUpdateMap()
  if mmp.settings.updatemap then
    mmp.echo('Will check for new map updates from your MUD.')
    enableTimer 'Check for updates periodically'
    mmp_checkupdatestart()
  else
    mmp.echo(&quot;Won't check for new map updates from your MUD.&quot;)
    disableTimer 'Check for updates periodically'
    if mmp.checkforupdatetimer then
      killTimer('mmp.checkforupdatetimer')
    end
  end
end</script>
                        <eventHandlerList>
                            <string>mmp logged in</string>
                        </eventHandlerList>
                    </Script>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>mmp_see_dl_errors</name>
                    <packageName></packageName>
                    <script>-- this should be off by default
function mmp_see_dl_errors(...)
  display{...}
end</script>
                    <eventHandlerList>
                        <string>sysDownloadError</string>
                    </eventHandlerList>
                </Script>
            </ScriptGroup>
            <Script isActive="yes" isFolder="no">
                <name>initialize</name>
                <packageName></packageName>
                <script>mmp.startup()</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>mmp.mapdata_changed</name>
                    <packageName></packageName>
                    <script>-- aggregates map load and such events into one
function mmp.mapdata_changed()
  raiseEvent(&quot;mmapper map reloaded&quot;)
end</script>
                    <eventHandlerList>
                        <string>sysMapLoad</string>
                        <string>sys2DMapLoad</string>
                        <string>sys3DMapLoad</string>
                        <string>sysMapDownloadEvent</string>
                        <string>mapOpenEvent</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>mmp_login</name>
                    <packageName></packageName>
                    <script>function mmp_login(...)

  send('protocol on', false)
  protocol = {}

  if mmp_protocol_trigger then killTrigger(mmp_protocol_trigger) end
  mmp_protocol_trigger = tempExactMatchTrigger('Initiating CLIENT / AVALON protocol codes.', [[deleteLine()]])

end</script>
                    <eventHandlerList>
                        <string>mmp logged in</string>
                    </eventHandlerList>
                </Script>
            </Script>
        </ScriptGroup>
    </ScriptPackage>
    <KeyPackage/>
    <HelpPackage>
        <helpURL></helpURL>
    </HelpPackage>
</MudletPackage>
